// This file is auto-generated by @hey-api/openapi-ts

export const $AssistantMessage = {
  type: 'object',
  description: 'Assistant message in the response',
  required: ['role'],
  properties: {
    content: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      description: 'The content of the message',
    },
    role: {
      $ref: '#/components/schemas/Role',
      description:
        'The role of the message author (always "assistant" for responses)',
    },
    tool_calls: {
      oneOf: [
        {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ToolCall',
          },
        },
        {
          type: 'null',
        },
      ],
      description: 'Tool calls made by the model, if any',
    },
  },
} as const;

export const $AudioFormat = {
  type: 'string',
  enum: ['mp3', 'opus', 'flac', 'wav', 'pcm'],
} as const;

export const $Character = {
  type: 'object',
  description: 'Character',
  required: [
    'id',
    'name',
    'description',
    'greeting',
    'voice_ids',
    'short_name',
  ],
  properties: {
    id: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    short_name: {
      type: 'string',
    },
    description: {
      type: 'string',
    },
    greeting: {
      type: 'string',
    },
    voice_ids: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    meta: {
      oneOf: [
        {
          type: 'null',
        },
        {
          $ref: '#/components/schemas/CharacterMetadata',
          description: 'Character meta',
        },
      ],
    },
  },
} as const;

export const $CharacterMinecraftMeta = {
  type: 'object',
  description: 'Character Minecraft meta',
  required: ['skin_url'],
  properties: {
    skin_url: {
      type: 'string',
      description: 'The URL of the skin',
    },
  },
} as const;

export const $CharacterMinecraftMetaTagged = {
  allOf: [
    {
      $ref: '#/components/schemas/CharacterMinecraftMeta',
    },
    {
      type: 'object',
      required: ['type'],
      properties: {
        type: {
          type: 'string',
          enum: ['Minecraft'],
        },
      },
    },
  ],
} as const;

export const $CharacterMetadata = {
  description: 'Character meta',
  oneOf: [
    {
      $ref: '#/components/schemas/CharacterMinecraftMetaTagged',
    },
  ],
} as const;

export const $JoulesResponse = {
  type: 'object',
  description: 'User joules and patron tier information',
  required: ['joules', 'patron_tier'],
  properties: {
    joules: {
      type: 'integer',
      description: "User's joule balance",
      example: 150,
    },
    patron_tier: {
      type: 'string',
      description: "User's patron tier (empty string if not a patron)",
      enum: ['', 'Patron Basic', 'Patron', 'Patron VIP', 'Patron VVIP'],
      example: 'Patron',
    },
  },
} as const;

export const $ChatCompletion = {
  type: 'object',
  description: 'Chat completion response',
  required: ['id', 'object', 'created', 'model', 'choices'],
  properties: {
    choices: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Choice',
      },
      description: 'A list of chat completion choices',
    },
    created: {
      type: 'integer',
      format: 'int64',
      description:
        'The Unix timestamp (in seconds) when the chat completion was created',
    },
    id: {
      type: 'string',
      description: 'Unique identifier for the chat completion',
    },
    model: {
      type: 'string',
      description: 'The model used for the chat completion',
    },
    object: {
      type: 'string',
      description: 'The object type, which is always "chat.completion"',
    },
    usage: {
      oneOf: [
        {
          type: 'null',
        },
        {
          $ref: '#/components/schemas/Usage',
          description: 'Usage statistics for the completion request',
        },
      ],
    },
  },
} as const;

export const $ChatCompletionJSONResponse = {
  type: 'object',
  description: 'Chat completion response',
  required: ['id', 'object', 'created', 'model', 'choices'],
  properties: {
    choices: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Choice',
      },
      description: 'A list of chat completion choices',
    },
    created: {
      type: 'integer',
      format: 'int64',
      description:
        'The Unix timestamp (in seconds) when the chat completion was created',
    },
    id: {
      type: 'string',
      description: 'Unique identifier for the chat completion',
    },
    model: {
      type: 'string',
      description: 'The model used for the chat completion',
    },
    object: {
      type: 'string',
      description: 'The object type, which is always "chat.completion"',
    },
    usage: {
      oneOf: [
        {
          type: 'null',
        },
        {
          $ref: '#/components/schemas/Usage',
          description: 'Usage statistics for the completion request',
        },
      ],
    },
  },
} as const;

export const $ChatCompletionStreamingResponse = {
  type: 'string',
} as const;

export const $ChatCompletionRequest = {
  type: 'object',
  description: 'Chat completion request',
  required: ['messages'],
  properties: {
    max_tokens: {
      oneOf: [
        {
          type: 'integer',
          format: 'int32',
        },
        {
          type: 'null',
        },
      ],
      description: 'The maximum number of tokens to generate in the completion',
    },
    messages: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Message',
      },
      description: 'Messages to complete',
    },
    stream: {
      oneOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      description:
        'Whether to stream the response (used for documentation, actual streaming determined by endpoint)',
    },
    temperature: {
      oneOf: [
        {
          type: 'number',
        },
        {
          type: 'null',
        },
      ],
      format: 'float',
      description: `What sampling temperature to use, between 0 and 2.
Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.`,
    },
    tool_choice: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      description: 'Controls how the model uses tools',
    },
    tools: {
      oneOf: [
        {
          type: 'array',
          items: {
            $ref: '#/components/schemas/Tool',
          },
        },
        {
          type: 'null',
        },
      ],
      description: 'Optional tools the model may call',
    },
  },
} as const;

export const $Choice = {
  type: 'object',
  description: 'Choice in the chat completion response',
  required: ['index', 'message', 'finish_reason'],
  properties: {
    finish_reason: {
      type: 'string',
      description: 'The reason the model stopped generating tokens',
    },
    index: {
      type: 'integer',
      format: 'int32',
      description: 'The index of the choice in the list of choices',
    },
    message: {
      $ref: '#/components/schemas/AssistantMessage',
      description: 'The message generated by the model',
    },
  },
} as const;

export const $Chunk = {
  type: 'object',
  description: `Chunk for streaming responses from LLMStreamProxy

This struct represents chunks received from the LLMStreamProxy gRPC API.
Each chunk contains raw data that should be written to the HTTP response as "data: {raw}"
When done=true, this indicates the final chunk and the connection should be closed.`,
  required: ['raw', 'done'],
  properties: {
    done: {
      type: 'boolean',
      description:
        'Whether this is the final chunk - when true, close the connection',
    },
    raw: {
      type: 'string',
      description: 'Raw data to be sent in the SSE stream as "data: {raw}"',
    },
  },
} as const;

export const $ContentBlock = {
  oneOf: [
    {
      allOf: [
        {
          $ref: '#/components/schemas/TextContent',
          description: 'Text content block',
        },
        {
          type: 'object',
          required: ['type'],
          properties: {
            type: {
              type: 'string',
              enum: ['text'],
            },
          },
        },
      ],
      description: 'Text content block',
    },
    {
      allOf: [
        {
          $ref: '#/components/schemas/ImageUrlContent',
          description: 'Image URL content block',
        },
        {
          type: 'object',
          required: ['type'],
          properties: {
            type: {
              type: 'string',
              enum: ['image_url'],
            },
          },
        },
      ],
      description: 'Image URL content block',
    },
  ],
  description: 'Content block for mixed content messages',
} as const;

export const $Function = {
  type: 'object',
  description: 'Function definition for a tool',
  required: ['name', 'description', 'parameters'],
  properties: {
    description: {
      type: 'string',
      description: 'Description of what the function does',
    },
    name: {
      type: 'string',
      description: 'The name of the function',
    },
    parameters: {
      $ref: '#/components/schemas/Parameters',
      description: 'Parameters the function accepts',
    },
    never_respond_with_message: {
      type: 'boolean',
      description: `Controls whether the NPC should provide a text response when calling this function.
- \`true\`: Function is executed silently without any accompanying text message (useful for background actions)
- \`false\`: Function is executed and the NPC may also provide a text response explaining the action
`,
      example: false,
    },
  },
} as const;

export const $FunctionCall = {
  type: 'object',
  description: 'Function call by the model',
  required: ['name', 'arguments'],
  properties: {
    arguments: {
      type: 'string',
      description: 'The arguments to pass to the function, JSON encoded',
    },
    name: {
      type: 'string',
      description: 'The name of the function to call',
    },
  },
} as const;

export const $SpeechGender = {
  type: 'string',
  enum: ['male', 'female', 'other'],
} as const;

export const $HealthResponse = {
  type: 'object',
  description: 'Health response',
} as const;

export const $ImageUrl = {
  type: 'object',
  description: 'Image URL details',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'The URL of the image (can be data URI or HTTP URL)',
    },
  },
} as const;

export const $ImageUrlContent = {
  type: 'object',
  description: 'Image URL content block',
  required: ['image_url'],
  properties: {
    image_url: {
      $ref: '#/components/schemas/ImageUrl',
      description:
        'Inline image data, following the format: data:image/<format>;base64,<data>',
    },
  },
} as const;

export const $LoginDeviceNewRequest = {
  type: 'object',
  description: 'Request to create a new device login',
  required: ['client_id'],
  properties: {
    client_id: {
      type: 'string',
      description: 'The Game Client ID. Find this in the Developer Dashboard.',
    },
  },
} as const;

export const $LoginDeviceNewResponse = {
  type: 'object',
  description: 'Response to a new device login',
  required: [
    'deviceCode',
    'userCode',
    'verificationUri',
    'verificationUriComplete',
    'expiresIn',
    'interval',
  ],
  properties: {
    deviceCode: {
      type: 'string',
      description: 'The device code you will use to poll for the api key.',
    },
    expiresIn: {
      type: 'integer',
      description: 'The number of seconds until the device code expires.',
    },
    interval: {
      type: 'integer',
      description:
        'The number of seconds between polling for the api key. You will receive a failure response if you poll too frequently.',
    },
    userCode: {
      type: 'string',
      description: 'The code the user may need to type in to approve access.',
    },
    verificationUri: {
      type: 'string',
      description:
        'The verification URI you should redirect the user to to approve access.',
    },
    verificationUriComplete: {
      type: 'string',
      description:
        "The complete verification URI you should redirect the user to to approve access. This full URI will have the site's `userCode automatically filled in.",
    },
  },
} as const;

export const $LoginDeviceTokenRequest = {
  type: 'object',
  description:
    'Request to exchange a device code for a P2 API key. You should poll this endpoint at fixed interval provided by the device code request.',
  required: ['client_id', 'device_code', 'grant_type'],
  properties: {
    client_id: {
      type: 'string',
      description:
        'The Game Client ID. Must match the Game Client ID that requested the device code.',
    },
    device_code: {
      type: 'string',
      description:
        'The device code received from the initial device code request.',
    },
    grant_type: {
      type: 'string',
      description:
        'The grant type. Must be equal to `urn:ietf:params:oauth:grant-type:device_code`',
    },
  },
} as const;

export const $LoginDeviceTokenResponse = {
  type: 'object',
  description: 'Response to a device code exchange request.',
  required: ['p2Key'],
  properties: {
    p2Key: {
      type: 'string',
      description:
        'The API key to use in the game. You must use the key in the Authorization header of your requests to the API with value `Bearer <p2Key>`.',
    },
  },
} as const;

export const $LoginAuthorizationCodeTokenRequest = {
  type: 'object',
  description:
    'Request to exchange an authorization code for a P2 API key using OAuth2 Authorization Code flow with PKCE.',
  required: [
    'grant_type',
    'code',
    'redirect_uri',
    'client_id',
    'code_verifier',
  ],
  properties: {
    grant_type: {
      type: 'string',
      description: 'The grant type. Must be equal to `authorization_code`',
      example: 'authorization_code',
    },
    code: {
      type: 'string',
      description:
        'The authorization code received from the authorization server.',
    },
    redirect_uri: {
      type: 'string',
      description:
        'The redirect URI that was used in the authorization request. Must match exactly.',
    },
    client_id: {
      type: 'string',
      description:
        'The Game Client ID. Must match the Game Client ID that was used in the authorization request.',
    },
    code_verifier: {
      type: 'string',
      description: `The original code verifier that was used to generate the code_challenge in the authorization request.
This must be the same cryptographically random string (43-128 characters) that you generated before starting the authorization flow.
The server will hash this verifier and compare it against the code_challenge you provided earlier to verify the request's authenticity.
`,
      example: 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk',
    },
  },
} as const;

export const $LoginAuthorizationCodeTokenResponse = {
  type: 'object',
  description: 'Response to an authorization code exchange request.',
  required: ['p2Key'],
  properties: {
    p2Key: {
      type: 'string',
      description:
        'The API key to use in the game. You must use the key in the Authorization header of your requests to the API with value `Bearer <p2Key>`.',
    },
  },
} as const;

export const $Message = {
  type: 'object',
  description: 'Message object',
  required: ['role', 'content'],
  properties: {
    content: {
      $ref: '#/components/schemas/MessageContent',
      description:
        'Content of the message - can be a string or array of content blocks',
    },
    role: {
      $ref: '#/components/schemas/Role',
      description:
        'Role of the message, must be one of "user", "assistant", "system", "developer"',
    },
    tool_call_id: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      description: 'Tool call ID, if the message is a tool call response',
    },
    tool_calls: {
      oneOf: [
        {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ToolCall',
          },
        },
        {
          type: 'null',
        },
      ],
      description: 'Tool calls, if the message is a tool call request',
    },
  },
} as const;

export const $MessageContent = {
  oneOf: [
    {
      type: 'string',
      description: 'Simple text content (for backward compatibility)',
    },
    {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ContentBlock',
      },
      description: 'Array of content blocks (text, images, etc.)',
    },
  ],
  description:
    'Message content that can be either a string or an array of content blocks',
} as const;

export const $Parameters = {
  type: 'object',
  description: 'Parameters for a function, matching the Go structure',
  required: ['type', 'properties'],
  properties: {
    properties: {
      type: 'object',
      description: 'Properties of the parameters',
      additionalProperties: {
        $ref: '#/components/schemas/Property',
      },
      propertyNames: {
        type: 'string',
      },
    },
    required: {
      oneOf: [
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
        {
          type: 'null',
        },
      ],
      description: 'List of required properties',
    },
    type: {
      type: 'string',
      description: 'Type of the parameters object',
    },
  },
} as const;

export const $Property = {
  type: 'object',
  description:
    'Property definition for parameters, following JSON Schema specification',
  properties: {
    type: {
      type: 'string',
      description:
        'The type of the property (e.g., string, number, object, array)',
    },
    description: {
      type: 'string',
      description: 'A description of the property',
    },
    enum: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'List of allowed values for the property',
    },
    items: {
      type: 'object',
      description: 'Schema for array items (when type is array)',
    },
    properties: {
      type: 'object',
      description: 'Nested properties (when type is object)',
      additionalProperties: {
        $ref: '#/components/schemas/Property',
      },
    },
    required: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'List of required properties (when type is object)',
    },
    minimum: {
      type: 'number',
      description: 'Minimum value for numeric types',
    },
    maximum: {
      type: 'number',
      description: 'Maximum value for numeric types',
    },
    format: {
      type: 'string',
      description: 'String format hint (e.g., date-time, email, uri)',
    },
  },
  additionalProperties: true,
} as const;

export const $RequestError = {
  type: 'object',
  required: ['message'],
  properties: {
    message: {
      type: 'string',
      description: 'Error message',
    },
  },
} as const;

export const $Role = {
  type: 'string',
  enum: ['user', 'assistant', 'system', 'developer', 'tool'],
} as const;

export const $SelectedCharactersResponse = {
  type: 'object',
  description: 'Response to a selected characters request',
  required: ['characters'],
  properties: {
    characters: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Character',
      },
      description: 'List of characters',
    },
  },
} as const;

export const $TextContent = {
  type: 'object',
  description: 'Text content block',
  required: ['text'],
  properties: {
    text: {
      type: 'string',
      description: 'The text content',
    },
  },
} as const;

export const $Tool = {
  type: 'object',
  description: 'Tool that can be called by the model',
  required: ['type', 'function'],
  properties: {
    function: {
      $ref: '#/components/schemas/Function',
      description: 'Function definition',
    },
    type: {
      type: 'string',
      description: 'Type of the tool, currently only "function" is supported',
    },
  },
} as const;

export const $ToolCall = {
  type: 'object',
  description: 'Tool call by the model',
  required: ['function'],
  properties: {
    function: {
      $ref: '#/components/schemas/FunctionCall',
      description: 'Function call details',
    },
    id: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      description: 'Unique ID for this tool call',
    },
    type: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      description:
        'Type of the tool call, currently only "function" is supported',
    },
  },
} as const;

export const $TTSSpeakRequest = {
  type: 'object',
  description: 'Request to speak a text',
  required: ['text', 'speed', 'audio_format'],
  properties: {
    text: {
      type: 'string',
      description: 'The text to speak',
      example: 'Hello, how are you?',
    },
    voice_ids: {
      type: 'array',
      description: `Voice ids to use. If not provided, the default voice for the language and gender will be used.
If providing more than one voice, the voices will be mixed together.
`,
      items: {
        type: 'string',
      },
    },
    speed: {
      type: 'number',
      format: 'double',
      minimum: 0.25,
      maximum: 4,
      description: 'Speed of the speech',
    },
    audio_format: {
      type: 'string',
      enum: ['mp3', 'opus', 'flac', 'wav', 'pcm'],
      description: 'The format of the audio',
    },
    voice_gender: {
      $ref: '#/components/schemas/SpeechGender',
      description:
        'The gender of the default voice to use if no voice_ids are provided.',
    },
    voice_language: {
      type: 'string',
      description:
        'The language of the default voice to use if no voice_ids are provided.',
      enum: [
        'en_US',
        'en_GB',
        'ja_JP',
        'zh_CN',
        'es_ES',
        'fr_FR',
        'hi_IN',
        'it_IT',
        'pt_BR',
      ],
    },
    advanced_voice: {
      type: 'object',
      description: 'Advanced voice configuration for enhanced control',
      properties: {
        instructions: {
          type: 'string',
          description:
            'Additional voice instructions to append to existing voice settings',
          example: 'Speak with a cheerful and energetic tone',
        },
      },
    },
  },
} as const;

export const $TTSStreamRequest = {
  type: 'object',
  description:
    'Request to stream text-to-speech audio (supports only WAV and MP3 formats)',
  required: ['text', 'speed', 'audio_format'],
  properties: {
    text: {
      type: 'string',
      description: 'The text to speak',
      example: 'Hello, how are you?',
    },
    voice_ids: {
      type: 'array',
      description: `Voice ids to use. If not provided, the default voice for the language and gender will be used.
If providing more than one voice, the voices will be mixed together.
`,
      items: {
        type: 'string',
      },
    },
    speed: {
      type: 'number',
      format: 'double',
      minimum: 0.25,
      maximum: 4,
      description: 'Speed of the speech',
    },
    audio_format: {
      type: 'string',
      enum: ['mp3', 'wav'],
      description:
        'The format of the streaming audio (only WAV and MP3 supported for streaming)',
    },
    voice_gender: {
      $ref: '#/components/schemas/SpeechGender',
      description:
        'The gender of the default voice to use if no voice_ids are provided.',
    },
    voice_language: {
      type: 'string',
      description:
        'The language of the default voice to use if no voice_ids are provided.',
      enum: [
        'en_US',
        'en_GB',
        'ja_JP',
        'zh_CN',
        'es_ES',
        'fr_FR',
        'hi_IN',
        'it_IT',
        'pt_BR',
      ],
    },
    advanced_voice: {
      type: 'object',
      description: 'Advanced voice configuration for enhanced control',
      properties: {
        instructions: {
          type: 'string',
          description:
            'Additional voice instructions to append to existing voice settings',
          example: 'Speak with a cheerful and energetic tone',
        },
      },
    },
    disable_advanced: {
      type: 'boolean',
      description:
        'If true, forces the use of Kokoro instead of Resemble even for patrons',
    },
  },
} as const;

export const $TTSSpeakResponse = {
  type: 'object',
  description: 'Response to a TTS speak request',
  required: ['data'],
  properties: {
    data: {
      type: 'string',
      description: 'The audio data in base64 format',
    },
  },
} as const;

export const $TTSVoicesResponse = {
  type: 'object',
  description: 'Response to a TTS voices request',
  required: ['voices'],
  properties: {
    voices: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/TTSVoice',
      },
      description: 'List of all available TTS voices',
    },
  },
} as const;

export const $TTSVoice = {
  type: 'object',
  description: 'TTS voice',
  required: ['id', 'name', 'language', 'gender'],
  properties: {
    id: {
      type: 'string',
      description: 'The ID of the voice',
    },
    name: {
      type: 'string',
      description: 'The name of the voice',
    },
    language: {
      type: 'string',
      description: 'The language of the voice',
    },
    gender: {
      $ref: '#/components/schemas/SpeechGender',
    },
  },
} as const;

export const $Usage = {
  type: 'object',
  description: 'Usage statistics for the completion request',
  required: ['prompt_tokens', 'completion_tokens', 'total_tokens'],
  properties: {
    completion_tokens: {
      type: 'integer',
      format: 'int64',
      description: 'Number of tokens in the generated completion',
    },
    prompt_tokens: {
      type: 'integer',
      format: 'int64',
      description: 'Number of tokens in the input',
    },
    total_tokens: {
      type: 'integer',
      format: 'int64',
      description: 'Total number of tokens used (prompt + completion)',
    },
  },
} as const;

export const $NpcChatCompletionRequest = {
  type: 'object',
  description: 'Request to send a message to an NPC',
  required: ['sender_name', 'sender_message'],
  properties: {
    game_state_info: {
      nullable: true,
      type: 'string',
      description: `Optional contextual information about the current state of your game world. This helps the NPC provide more relevant and immersive responses.
Include details like location, weather, time of day, nearby objects or characters, player inventory, quest status, or any other relevant context.
The more specific and detailed this information, the better the NPC can tailor its response to the situation.
`,
      example:
        "Player is in the Mystic Forest at dusk. It's raining lightly. Player has a magic sword and 150 gold. Current quest: Find the Crystal of Power. A mysterious owl is perched nearby watching.",
    },
    sender_message: {
      type: 'string',
      description: `The message content from the player to the NPC. This can be dialogue, questions, commands, or any other form of communication.
The NPC will respond based on its personality, the message content, and any provided game state context.
`,
      example:
        "Hello, wise sage! I'm on a quest to find the Crystal of Power. Do you know where I might find it?",
    },
    sender_name: {
      type: 'string',
      description: `The name or identifier of the player sending the message. The NPC will use this to personalize responses and maintain conversational context.
Can be a character name, username, or any identifier that makes sense in your game context.
`,
      example: 'Alex the Adventurer',
    },
    tts: {
      nullable: true,
      $ref: '#/components/schemas/NpcTTS',
      description: `Specifies how text-to-speech audio should be handled for the NPC's response.
- \`"server"\`: Audio is generated on our servers and returned as base64-encoded data
- \`null\`: No audio generation - text response only
`,
    },
  },
  example: {
    game_state_info:
      'The weather is currently 30°C, it may be appropriate to call the "cool the weather" function',
    sender_message: 'Hello, how are you doing today?',
    sender_name: 'John',
  },
} as const;

export const $NpcApiChatResponse = {
  type: 'object',
  description: `Response from an NPC containing text message, optional audio, and/or function calls.
This is the format of responses streamed through the \`/npcs/responses\` endpoint.
`,
  required: ['npc_id', 'message'],
  properties: {
    audio: {
      oneOf: [
        {
          type: 'null',
        },
        {
          $ref: '#/components/schemas/SingleTextToSpeechData',
        },
      ],
      description: `Optional audio data for the NPC's response. Present only if TTS was requested in the original message.
Contains base64-encoded audio data ready for playback.
`,
    },
    command: {
      oneOf: [
        {
          type: 'array',
          items: {
            $ref: '#/components/schemas/FunctionCall',
          },
        },
        {
          type: 'null',
        },
      ],
      description: `Optional array of function calls that the NPC wants to execute. These represent actions the NPC is taking in your game world.
Your game should process these function calls and apply their effects. Functions can modify game state, trigger events, or perform other actions.
`,
    },
    error: {
      oneOf: [
        {
          type: 'null',
        },
        {
          $ref: '#/components/schemas/NpcApiError',
        },
      ],
      description: `Optional error information when the NPC cannot process a request due to system issues.
When present, indicates that the NPC encountered an error and cannot provide a normal response.
`,
    },
    message: {
      type: 'string',
      description: `The text response from the NPC. This is the conversational content that should be displayed to the player.
May be empty if the NPC is only executing functions without providing a text response, or if an error occurred.
`,
      example:
        "Ahoy there, brave adventurer! I've heard tales of the Crystal of Power. *adjusts weather to be more favorable* The path lies through the Misty Mountains, but beware of the ancient guardians!",
    },
    npc_id: {
      type: 'string',
      format: 'uuid',
      description: `The unique identifier of the NPC that generated this response. Use this to route the response to the correct character in your game.
This matches the UUID returned when the NPC was spawned.
`,
      example: '123e4567-e89b-12d3-a456-426614174000',
    },
  },
} as const;

export const $NpcApiError = {
  type: 'object',
  description: `Error information for NPC API responses when system errors occur.
Provides structured error details to help developers handle different error conditions.
`,
  required: ['error_code', 'error_message'],
  properties: {
    error_code: {
      type: 'string',
      enum: [
        'insufficient_credits',
        'service_unavailable',
        'rate_limited',
        'internal_error',
      ],
      description: `Machine-readable error code indicating the type of error that occurred.
- \`insufficient_credits\`: User has run out of AI power/credits and needs to top up their account
- \`service_unavailable\`: The AI service is temporarily unavailable
- \`rate_limited\`: Too many requests have been made in a short time period
- \`internal_error\`: An unexpected system error occurred
`,
      example: 'insufficient_credits',
    },
    error_message: {
      type: 'string',
      description: `Human-readable error message providing details about the error.
This message can be displayed to users to explain what went wrong and how to resolve it.
`,
      example:
        'Insufficient AI power for completing the request. Get more AI power from https://player2.game/profile/ai-power.',
    },
    retry_after: {
      oneOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      description: `Optional number of seconds to wait before retrying the request.
Present for rate_limited and service_unavailable errors.
`,
      example: 60,
    },
  },
} as const;

export const $NpcHistoryResponse = {
  type: 'object',
  description: `Response containing the complete conversation history for an NPC.
Includes all messages exchanged between players and the NPC in chronological order.
`,
  required: ['npc_id', 'history'],
  properties: {
    npc_id: {
      type: 'string',
      format: 'uuid',
      description: `The unique identifier of the NPC whose history is being returned.
This matches the UUID returned when the NPC was spawned.
`,
      example: '123e4567-e89b-12d3-a456-426614174000',
    },
    history: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Message',
      },
      description: `Array of conversation messages in chronological order.
Contains all user and assistant messages that form the NPC's conversation context.
`,
      example: [
        {
          role: 'user',
          content: "Hello there, what's your name?",
        },
        {
          role: 'assistant',
          content:
            "Ahoy! I'm Captain Blackbeard, the fiercest pirate on these seas!",
        },
        {
          role: 'user',
          content: 'Can you help me find treasure?',
        },
        {
          role: 'assistant',
          content:
            'Aye, I know where the golden doubloons be buried! Follow me compass, matey.',
        },
      ],
    },
  },
} as const;

export const $NpcFunction = {
  allOf: [
    {
      $ref: '#/components/schemas/Function',
    },
    {
      type: 'object',
      description: `Defines a custom function that an NPC can execute to interact with your game world.
Extends the base Function schema with NPC-specific behavior controls.
`,
      properties: {},
    },
  ],
} as const;

export const $SingleTextToSpeechData = {
  type: 'object',
  description: 'Single Text to Speech Data',
  required: ['data'],
  properties: {
    data: {
      type: 'string',
      description: 'Base64 encoded audio data',
    },
  },
} as const;

export const $NpcTTSConfig = {
  type: 'object',
  description: `Text-to-speech configuration for an NPC. This defines how the NPC's responses should be converted to audio.
All fields from TTSSpeakRequest except 'text' are supported, allowing full control over voice characteristics.
`,
  required: ['speed', 'audio_format'],
  properties: {
    voice_ids: {
      type: 'array',
      description: `Voice ids to use for this NPC. If not provided, the default voice for the language and gender will be used.
If providing more than one voice, the voices will be mixed together.
`,
      items: {
        type: 'string',
      },
      example: ['21m00Tcm4TlvDq8ikWAM'],
    },
    speed: {
      type: 'number',
      format: 'double',
      minimum: 0.25,
      maximum: 4,
      description: 'Speed of the speech for this NPC',
      example: 1,
    },
    audio_format: {
      type: 'string',
      enum: ['mp3', 'opus', 'flac', 'wav', 'pcm'],
      description: "The audio format for this NPC's responses",
      example: 'mp3',
    },
    voice_gender: {
      $ref: '#/components/schemas/SpeechGender',
      description:
        'The gender of the default voice to use if no voice_ids are provided',
    },
    voice_language: {
      type: 'string',
      description:
        'The language of the default voice to use if no voice_ids are provided',
      enum: [
        'en_US',
        'en_GB',
        'ja_JP',
        'zh_CN',
        'es_ES',
        'fr_FR',
        'hi_IN',
        'it_IT',
        'pt_BR',
      ],
      example: 'en_US',
    },
  },
} as const;

export const $SpawnNPC = {
  type: 'object',
  required: [
    'short_name',
    'name',
    'character_description',
    'system_prompt',
    'tts',
  ],
  properties: {
    character_description: {
      type: 'string',
      description: `A detailed description of your NPC's personality, background, and traits. This shapes how the AI will behave and respond to players.
Think of this as the character's "bio" - include their motivations, quirks, speaking style, and any unique characteristics.
`,
      example:
        'A weathered pirate captain with a thick accent who loves treasure hunting and telling tales of the sea. Known for being both cunning and surprisingly helpful to those who show respect.',
    },
    commands: {
      oneOf: [
        {
          type: 'array',
          items: {
            $ref: '#/components/schemas/NpcFunction',
          },
        },
        {
          type: 'null',
        },
      ],
      description: `An optional array of custom functions/commands that your NPC can execute. These allow the NPC to interact with your game world beyond just conversation.
Each function should have a clear purpose and well-defined parameters. The NPC will intelligently decide when to call these functions based on the conversation context.
`,
    },
    keep_game_state: {
      oneOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      description: `Controls whether game state information is preserved in the NPC's conversation history.
- \`true\` (default): Game state context is remembered across conversations for continuity
- \`false\`: Each conversation starts fresh without previous game state context
- \`null\`: Uses system default behavior
`,
    },
    name: {
      type: 'string',
      description: `The complete, formal name of your character. This is used for identification and can be referenced in conversations.
Use a name that fits your game's setting and the character's background.
`,
      example: 'Captain Blackbeard McReynolds',
    },
    short_name: {
      type: 'string',
      description: `A shorter version of the character's name, typically used in UI elements like chat bubbles or character lists.
This should be easy to read and recognize at a glance.
`,
      example: 'Captain',
    },
    system_prompt: {
      type: 'string',
      description: `Core instructions that define how the AI should behave as this character. This is the most important field for shaping your NPC's personality and behavior.
Include guidelines for tone, knowledge areas, goals, and any specific rules the character should follow.
`,
      example:
        "You are Captain Blackbeard, a seasoned pirate with a heart of gold. Speak with a nautical accent and pirate terminology. Help players with their quests while sharing tales of your adventures. You're knowledgeable about sailing, treasure hunting, and sea monsters.",
    },
    tts: {
      $ref: '#/components/schemas/NpcTTSConfig',
      description: `Text-to-speech configuration for this NPC. Defines voice characteristics, speed, and audio format for when players request audio responses.
Use the [/tts/voices](#tag/Text-To-Speech/operation/tts_voices) endpoint to get available voice options and their IDs.
`,
    },
    voice_id: {
      type: 'string',
      description: `**Backward compatibility field for player2 app.**
Voice ID to use for this NPC. If both \`voice_id\` and \`tts.voice_id\` are provided, \`tts.voice_id\` takes precedence.
If \`tts.voice_id\` is empty, this field will be used instead.
`,
      example: '01955d76-ed5b-7451-92d6-5ef579d3ed28',
    },
  },
  examples: [
    {
      character_description: 'A crazed scientist on the hunt for gold',
      commands: [
        {
          description:
            'takes in a value, and modifies the weather by that many degrees celcius',
          name: 'weather_modifier',
          parameters: {
            properties: {
              degrees: {
                description:
                  'The number of degrees to modify the weather by, can be negative or positive',
                type: 'integer',
              },
            },
            required: ['degrees'],
            type: 'object',
          },
          never_respond_with_message: false,
        },
      ],
      name: 'Victor J. Johnson',
      short_name: 'Victor',
      system_prompt: 'Prompt',
      tts: {
        voice_ids: ['01955d76-ed5b-7451-92d6-5ef579d3ed28'],
        speed: 1,
        audio_format: 'mp3',
      },
    },
  ],
} as const;

export const $NpcTTS = {
  type: 'string',
  description: `Specifies how text-to-speech audio should be generated and delivered for NPC responses.
Choose the option that best fits your application's architecture and bandwidth requirements.
`,
  enum: ['server'],
  'x-enum-descriptions': [
    'Audio is generated on our servers and returned as base64-encoded data. Recommended for most applications as it provides consistent quality and reduces client complexity.',
  ],
} as const;

export const $STTEnvelope = {
  type: 'object',
  description: 'WebSocket message envelope for STT events',
  required: ['type', 'stream_id', 'timestamp', 'data'],
  properties: {
    type: {
      type: 'string',
      enum: [
        'session',
        'open',
        'message',
        'speech_started',
        'utterance_end',
        'error',
        'close',
      ],
      description: 'Event type',
    },
    stream_id: {
      type: 'string',
      description: 'Stream session identifier',
    },
    timestamp: {
      type: 'integer',
      format: 'int64',
      description: 'Unix timestamp in milliseconds',
    },
    data: {
      oneOf: [
        {
          $ref: '#/components/schemas/STTSessionEvent',
        },
        {
          $ref: '#/components/schemas/STTOpenEvent',
        },
        {
          $ref: '#/components/schemas/STTMessageEvent',
        },
        {
          $ref: '#/components/schemas/STTSpeechStartedEvent',
        },
        {
          $ref: '#/components/schemas/STTUtteranceEndEvent',
        },
        {
          $ref: '#/components/schemas/STTErrorEvent',
        },
        {
          $ref: '#/components/schemas/STTCloseEvent',
        },
      ],
      description: 'Event-specific data',
    },
  },
} as const;

export const $STTSessionEvent = {
  type: 'object',
  description: 'Session establishment event',
  required: ['stream_id'],
  properties: {
    stream_id: {
      type: 'string',
      description: 'Unique session identifier for reconnection',
    },
  },
} as const;

export const $STTOpenEvent = {
  type: 'object',
  description: 'Transcriber connection opened event',
  properties: {
    type: {
      type: 'string',
      example: 'Open',
    },
  },
} as const;

export const $STTMessageEvent = {
  type: 'object',
  description: 'Transcription result event (interim or final)',
  properties: {
    channel: {
      $ref: '#/components/schemas/STTChannel',
    },
    channel_index: {
      type: 'array',
      items: {
        type: 'integer',
      },
    },
    duration: {
      type: 'number',
      format: 'double',
    },
    is_final: {
      type: 'boolean',
      description: 'Whether this is the final transcription result',
    },
    from_finalize: {
      type: 'boolean',
    },
    metadata: {
      $ref: '#/components/schemas/STTMetadata',
    },
    speech_final: {
      type: 'boolean',
    },
    start: {
      type: 'number',
      format: 'double',
    },
    type: {
      type: 'string',
    },
  },
} as const;

export const $STTChannel = {
  type: 'object',
  description: 'Transcription channel data',
  properties: {
    alternatives: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/STTAlternative',
      },
    },
  },
} as const;

export const $STTAlternative = {
  type: 'object',
  description: 'Transcription alternative result',
  properties: {
    confidence: {
      type: 'number',
      format: 'double',
      description: 'Confidence score (0.0 to 1.0)',
    },
    transcript: {
      type: 'string',
      description: 'Transcribed text',
    },
    words: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/STTWord',
      },
    },
  },
} as const;

export const $STTWord = {
  type: 'object',
  description: 'Individual word with timing information',
  properties: {
    word: {
      type: 'string',
      description: 'The transcribed word',
    },
    start: {
      type: 'number',
      format: 'double',
      description: 'Start time in seconds',
    },
    end: {
      type: 'number',
      format: 'double',
      description: 'End time in seconds',
    },
    confidence: {
      type: 'number',
      format: 'double',
      description: 'Confidence score for this word',
    },
    speaker: {
      type: 'integer',
      description: 'Speaker identifier (when diarization is enabled)',
    },
  },
} as const;

export const $STTMetadata = {
  type: 'object',
  description: 'Transcription metadata',
  properties: {
    request_id: {
      type: 'string',
    },
    transaction_key: {
      type: 'string',
    },
    sha256: {
      type: 'string',
    },
    created: {
      type: 'string',
    },
    duration: {
      type: 'number',
      format: 'double',
    },
    channels: {
      type: 'integer',
    },
  },
} as const;

export const $STTSpeechStartedEvent = {
  type: 'object',
  description: 'Voice activity detection - speech started',
  properties: {
    type: {
      type: 'string',
      example: 'SpeechStarted',
    },
  },
} as const;

export const $STTUtteranceEndEvent = {
  type: 'object',
  description: 'End of utterance detected (silence after speech)',
  properties: {
    type: {
      type: 'string',
      example: 'UtteranceEnd',
    },
  },
} as const;

export const $STTErrorEvent = {
  type: 'object',
  description: 'Error event from transcriber',
  required: ['err_code', 'err_msg'],
  properties: {
    type: {
      type: 'string',
      example: 'Error',
    },
    err_code: {
      type: 'string',
      enum: [
        'CONNECTION_FAILED',
        'CONNECTION_TIMEOUT',
        'CONNECTION_LOST',
        'RECONNECT_FAILED',
        'AUTHENTICATION_FAILED',
        'INVALID_API_KEY',
        'UNAUTHORIZED',
        'INVALID_CONFIGURATION',
        'UNSUPPORTED_FORMAT',
        'INVALID_SAMPLE_RATE',
        'AUDIO_VALIDATION_ERROR',
        'BUFFER_OVERFLOW',
        'AUDIO_PROCESSING_ERROR',
        'RATE_LIMIT_EXCEEDED',
        'QUOTA_EXCEEDED',
        'SESSION_NOT_FOUND',
        'SESSION_EXPIRED',
        'SESSION_CLOSED',
        'INTERNAL_ERROR',
        'SERVICE_UNAVAILABLE',
        'DEEPGRAM_ERROR',
      ],
      description: 'Specific error code',
    },
    err_msg: {
      type: 'string',
      description: 'Human-readable error message',
    },
    description: {
      type: 'string',
      description: 'Detailed error description',
    },
    variant: {
      type: 'string',
      example: 'error',
    },
  },
} as const;

export const $STTCloseEvent = {
  type: 'object',
  description: 'Connection closed event',
  properties: {
    type: {
      type: 'string',
      example: 'Close',
    },
  },
} as const;

export const $AudioConfig = {
  type: 'object',
  description: 'Audio configuration for transcription',
  properties: {
    encoding: {
      type: 'string',
      enum: ['linear16', 'flac', 'mulaw', 'alaw', 'mp3', 'mp4', 'opus', 'wav'],
      description: 'Audio encoding format',
    },
    sample_rate: {
      type: 'string',
      pattern: '^[1-9]\\d*$',
      description: 'Audio sample rate in Hz (e.g., "44100", "48000")',
    },
    language: {
      type: 'string',
      enum: [
        'en',
        'en-US',
        'en-AU',
        'en-GB',
        'en-NZ',
        'en-IN',
        'es',
        'es-419',
        'fr',
        'fr-CA',
        'de',
        'it',
        'pt',
        'pt-BR',
        'ru',
        'hi',
        'ja',
        'ko',
        'zh',
        'zh-CN',
        'zh-TW',
        'nl',
        'tr',
        'pl',
        'sv',
        'no',
        'da',
        'fi',
        'uk',
        'el',
        'cs',
      ],
      description: 'BCP-47 language tag for transcription',
    },
  },
} as const;

export const $AudioTranscription = {
  type: 'object',
  description: 'Audio transcription result',
  required: ['transcript', 'confidence'],
  properties: {
    transcript: {
      type: 'string',
      description: 'The transcribed text from the audio',
    },
    confidence: {
      type: 'number',
      format: 'double',
      minimum: 0,
      maximum: 1,
      description: 'Confidence score for the transcription (0.0 to 1.0)',
    },
    words: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/STTWord',
      },
      description: 'Individual words with timing information (optional)',
    },
    duration: {
      type: 'number',
      format: 'double',
      description: 'Duration of the audio in seconds',
    },
  },
} as const;
