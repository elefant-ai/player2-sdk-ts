// This file is auto-generated by @hey-api/openapi-ts

/**
 * Assistant message in the response
 */
export type AssistantMessage = {
  /**
   * The content of the message
   */
  content?: string | null;
  /**
   * The role of the message author (always "assistant" for responses)
   */
  role: Role;
  /**
   * Tool calls made by the model, if any
   */
  tool_calls?: Array<ToolCall> | null;
};

export type AudioFormat = 'mp3' | 'opus' | 'flac' | 'wav' | 'pcm';

/**
 * Character
 */
export type Character = {
  id: string;
  name: string;
  short_name: string;
  description: string;
  greeting: string;
  voice_ids: Array<string>;
  meta?: null | CharacterMetadata;
};

/**
 * Character Minecraft meta
 */
export type CharacterMinecraftMeta = {
  /**
   * The URL of the skin
   */
  skin_url: string;
};

export type CharacterMinecraftMetaTagged = CharacterMinecraftMeta & {
  type: 'Minecraft';
};

export type type = 'Minecraft';

/**
 * Character meta
 */
export type CharacterMetadata = CharacterMinecraftMetaTagged;

/**
 * User joules and patron tier information
 */
export type JoulesResponse = {
  /**
   * User's joule balance
   */
  joules: number;
  /**
   * User's patron tier (empty string if not a patron)
   */
  patron_tier: '' | 'Patron Basic' | 'Patron' | 'Patron VIP' | 'Patron VVIP';
};

/**
 * User's patron tier (empty string if not a patron)
 */
export type patron_tier =
  | ''
  | 'Patron Basic'
  | 'Patron'
  | 'Patron VIP'
  | 'Patron VVIP';

/**
 * Chat completion response
 */
export type ChatCompletion = {
  /**
   * A list of chat completion choices
   */
  choices: Array<Choice>;
  /**
   * The Unix timestamp (in seconds) when the chat completion was created
   */
  created: number;
  /**
   * Unique identifier for the chat completion
   */
  id: string;
  /**
   * The model used for the chat completion
   */
  model: string;
  /**
   * The object type, which is always "chat.completion"
   */
  object: string;
  usage?: null | Usage;
};

/**
 * Chat completion response
 */
export type ChatCompletionJSONResponse = {
  /**
   * A list of chat completion choices
   */
  choices: Array<Choice>;
  /**
   * The Unix timestamp (in seconds) when the chat completion was created
   */
  created: number;
  /**
   * Unique identifier for the chat completion
   */
  id: string;
  /**
   * The model used for the chat completion
   */
  model: string;
  /**
   * The object type, which is always "chat.completion"
   */
  object: string;
  usage?: null | Usage;
};

export type ChatCompletionStreamingResponse = string;

/**
 * Chat completion request
 */
export type ChatCompletionRequest = {
  /**
   * The maximum number of tokens to generate in the completion
   */
  max_tokens?: number | null;
  /**
   * Messages to complete
   */
  messages: Array<Message>;
  /**
   * Whether to stream the response (used for documentation, actual streaming determined by endpoint)
   */
  stream?: boolean | null;
  /**
   * What sampling temperature to use, between 0 and 2.
   * Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null;
  /**
   * Controls how the model uses tools
   */
  tool_choice?: string | null;
  /**
   * Optional tools the model may call
   */
  tools?: Array<Tool> | null;
};

/**
 * Choice in the chat completion response
 */
export type Choice = {
  /**
   * The reason the model stopped generating tokens
   */
  finish_reason: string;
  /**
   * The index of the choice in the list of choices
   */
  index: number;
  /**
   * The message generated by the model
   */
  message: AssistantMessage;
};

/**
 * Chunk for streaming responses from LLMStreamProxy
 *
 * This struct represents chunks received from the LLMStreamProxy gRPC API.
 * Each chunk contains raw data that should be written to the HTTP response as "data: {raw}"
 * When done=true, this indicates the final chunk and the connection should be closed.
 */
export type Chunk = {
  /**
   * Whether this is the final chunk - when true, close the connection
   */
  done: boolean;
  /**
   * Raw data to be sent in the SSE stream as "data: {raw}"
   */
  raw: string;
};

/**
 * Content block for mixed content messages
 */
export type ContentBlock =
  | (TextContent & {
      type: 'text';
    })
  | (ImageUrlContent & {
      type: 'image_url';
    });

export type type2 = 'text';

/**
 * Function definition for a tool
 */
export type Function = {
  /**
   * Description of what the function does
   */
  description: string;
  /**
   * The name of the function
   */
  name: string;
  /**
   * Parameters the function accepts
   */
  parameters: Parameters;
  /**
   * Controls whether the NPC should provide a text response when calling this function.
   * - `true`: Function is executed silently without any accompanying text message (useful for background actions)
   * - `false`: Function is executed and the NPC may also provide a text response explaining the action
   *
   */
  never_respond_with_message?: boolean;
};

/**
 * Function call by the model
 */
export type FunctionCall = {
  /**
   * The arguments to pass to the function, JSON encoded
   */
  arguments: string;
  /**
   * The name of the function to call
   */
  name: string;
};

export type SpeechGender = 'male' | 'female' | 'other';

/**
 * Health response
 */
export type HealthResponse = {
  [key: string]: unknown;
};

/**
 * Image URL details
 */
export type ImageUrl = {
  /**
   * The URL of the image (can be data URI or HTTP URL)
   */
  url: string;
};

/**
 * Image URL content block
 */
export type ImageUrlContent = {
  /**
   * Inline image data, following the format: data:image/<format>;base64,<data>
   */
  image_url: ImageUrl;
};

/**
 * Request to create a new device login
 */
export type LoginDeviceNewRequest = {
  /**
   * The Game Client ID. Find this in the Developer Dashboard.
   */
  client_id: string;
};

/**
 * Response to a new device login
 */
export type LoginDeviceNewResponse = {
  /**
   * The device code you will use to poll for the api key.
   */
  deviceCode: string;
  /**
   * The number of seconds until the device code expires.
   */
  expiresIn: number;
  /**
   * The number of seconds between polling for the api key. You will receive a failure response if you poll too frequently.
   */
  interval: number;
  /**
   * The code the user may need to type in to approve access.
   */
  userCode: string;
  /**
   * The verification URI you should redirect the user to to approve access.
   */
  verificationUri: string;
  /**
   * The complete verification URI you should redirect the user to to approve access. This full URI will have the site's `userCode automatically filled in.
   */
  verificationUriComplete: string;
};

/**
 * Request to exchange a device code for a P2 API key. You should poll this endpoint at fixed interval provided by the device code request.
 */
export type LoginDeviceTokenRequest = {
  /**
   * The Game Client ID. Must match the Game Client ID that requested the device code.
   */
  client_id: string;
  /**
   * The device code received from the initial device code request.
   */
  device_code: string;
  /**
   * The grant type. Must be equal to `urn:ietf:params:oauth:grant-type:device_code`
   */
  grant_type: string;
};

/**
 * Response to a device code exchange request.
 */
export type LoginDeviceTokenResponse = {
  /**
   * The API key to use in the game. You must use the key in the Authorization header of your requests to the API with value `Bearer <p2Key>`.
   */
  p2Key: string;
};

/**
 * Request to exchange an authorization code for a P2 API key using OAuth2 Authorization Code flow with PKCE.
 */
export type LoginAuthorizationCodeTokenRequest = {
  /**
   * The grant type. Must be equal to `authorization_code`
   */
  grant_type: string;
  /**
   * The authorization code received from the authorization server.
   */
  code: string;
  /**
   * The redirect URI that was used in the authorization request. Must match exactly.
   */
  redirect_uri: string;
  /**
   * The Game Client ID. Must match the Game Client ID that was used in the authorization request.
   */
  client_id: string;
  /**
   * The original code verifier that was used to generate the code_challenge in the authorization request.
   * This must be the same cryptographically random string (43-128 characters) that you generated before starting the authorization flow.
   * The server will hash this verifier and compare it against the code_challenge you provided earlier to verify the request's authenticity.
   *
   */
  code_verifier: string;
};

/**
 * Response to an authorization code exchange request.
 */
export type LoginAuthorizationCodeTokenResponse = {
  /**
   * The API key to use in the game. You must use the key in the Authorization header of your requests to the API with value `Bearer <p2Key>`.
   */
  p2Key: string;
};

/**
 * Message object
 */
export type Message = {
  /**
   * Content of the message - can be a string or array of content blocks
   */
  content: MessageContent;
  /**
   * Role of the message, must be one of "user", "assistant", "system", "developer"
   */
  role: Role;
  /**
   * Tool call ID, if the message is a tool call response
   */
  tool_call_id?: string | null;
  /**
   * Tool calls, if the message is a tool call request
   */
  tool_calls?: Array<ToolCall> | null;
};

/**
 * Message content that can be either a string or an array of content blocks
 */
export type MessageContent = string | Array<ContentBlock>;

/**
 * Parameters for a function, matching the Go structure
 */
export type Parameters = {
  /**
   * Properties of the parameters
   */
  properties: {
    [key: string]: Property;
  };
  /**
   * List of required properties
   */
  required?: Array<string> | null;
  /**
   * Type of the parameters object
   */
  type: string;
};

/**
 * Property definition for parameters, following JSON Schema specification
 */
export type Property = {
  /**
   * The type of the property (e.g., string, number, object, array)
   */
  type?: string;
  /**
   * A description of the property
   */
  description?: string;
  /**
   * List of allowed values for the property
   */
  enum?: Array<string>;
  /**
   * Schema for array items (when type is array)
   */
  items?: {
    [key: string]: unknown;
  };
  /**
   * Nested properties (when type is object)
   */
  properties?: {
    [key: string]: Property;
  };
  /**
   * List of required properties (when type is object)
   */
  required?: Array<string>;
  /**
   * Minimum value for numeric types
   */
  minimum?: number;
  /**
   * Maximum value for numeric types
   */
  maximum?: number;
  /**
   * String format hint (e.g., date-time, email, uri)
   */
  format?: string;
  [key: string]: unknown | string | Property | number;
};

export type RequestError = {
  /**
   * Error message
   */
  message: string;
};

export type Role = 'user' | 'assistant' | 'system' | 'developer' | 'tool';

/**
 * Response to a selected characters request
 */
export type SelectedCharactersResponse = {
  /**
   * List of characters
   */
  characters: Array<Character>;
};

/**
 * Text content block
 */
export type TextContent = {
  /**
   * The text content
   */
  text: string;
};

/**
 * Tool that can be called by the model
 */
export type Tool = {
  /**
   * Function definition
   */
  function: Function;
  /**
   * Type of the tool, currently only "function" is supported
   */
  type: string;
};

/**
 * Tool call by the model
 */
export type ToolCall = {
  /**
   * Function call details
   */
  function: FunctionCall;
  /**
   * Unique ID for this tool call
   */
  id?: string | null;
  /**
   * Type of the tool call, currently only "function" is supported
   */
  type?: string | null;
};

/**
 * Request to speak a text
 */
export type TTSSpeakRequest = {
  /**
   * The text to speak
   */
  text: string;
  /**
   * Voice ids to use. If not provided, the default voice for the language and gender will be used.
   * If providing more than one voice, the voices will be mixed together.
   *
   */
  voice_ids?: Array<string>;
  /**
   * Speed of the speech
   */
  speed: number;
  /**
   * The format of the audio
   */
  audio_format: 'mp3' | 'opus' | 'flac' | 'wav' | 'pcm';
  /**
   * The gender of the default voice to use if no voice_ids are provided.
   */
  voice_gender?: SpeechGender;
  /**
   * The language of the default voice to use if no voice_ids are provided.
   */
  voice_language?:
    | 'en_US'
    | 'en_GB'
    | 'ja_JP'
    | 'zh_CN'
    | 'es_ES'
    | 'fr_FR'
    | 'hi_IN'
    | 'it_IT'
    | 'pt_BR';
  /**
   * Advanced voice configuration for enhanced control
   */
  advanced_voice?: {
    /**
     * Additional voice instructions to append to existing voice settings
     */
    instructions?: string;
  };
};

/**
 * The format of the audio
 */
export type audio_format = 'mp3' | 'opus' | 'flac' | 'wav' | 'pcm';

/**
 * The language of the default voice to use if no voice_ids are provided.
 */
export type voice_language =
  | 'en_US'
  | 'en_GB'
  | 'ja_JP'
  | 'zh_CN'
  | 'es_ES'
  | 'fr_FR'
  | 'hi_IN'
  | 'it_IT'
  | 'pt_BR';

/**
 * Request to stream text-to-speech audio (supports only WAV and MP3 formats)
 */
export type TTSStreamRequest = {
  /**
   * The text to speak
   */
  text: string;
  /**
   * Voice ids to use. If not provided, the default voice for the language and gender will be used.
   * If providing more than one voice, the voices will be mixed together.
   *
   */
  voice_ids?: Array<string>;
  /**
   * Speed of the speech
   */
  speed: number;
  /**
   * The format of the streaming audio (only WAV and MP3 supported for streaming)
   */
  audio_format: 'mp3' | 'wav';
  /**
   * The gender of the default voice to use if no voice_ids are provided.
   */
  voice_gender?: SpeechGender;
  /**
   * The language of the default voice to use if no voice_ids are provided.
   */
  voice_language?:
    | 'en_US'
    | 'en_GB'
    | 'ja_JP'
    | 'zh_CN'
    | 'es_ES'
    | 'fr_FR'
    | 'hi_IN'
    | 'it_IT'
    | 'pt_BR';
  /**
   * Advanced voice configuration for enhanced control
   */
  advanced_voice?: {
    /**
     * Additional voice instructions to append to existing voice settings
     */
    instructions?: string;
  };
  /**
   * If true, forces the use of Kokoro instead of Resemble even for patrons
   */
  disable_advanced?: boolean;
};

/**
 * The format of the streaming audio (only WAV and MP3 supported for streaming)
 */
export type audio_format2 = 'mp3' | 'wav';

/**
 * Response to a TTS speak request
 */
export type TTSSpeakResponse = {
  /**
   * The audio data in base64 format
   */
  data: string;
};

/**
 * Response to a TTS voices request
 */
export type TTSVoicesResponse = {
  /**
   * List of all available TTS voices
   */
  voices: Array<TTSVoice>;
};

/**
 * TTS voice
 */
export type TTSVoice = {
  /**
   * The ID of the voice
   */
  id: string;
  /**
   * The name of the voice
   */
  name: string;
  /**
   * The language of the voice
   */
  language: string;
  gender: SpeechGender;
};

/**
 * Usage statistics for the completion request
 */
export type Usage = {
  /**
   * Number of tokens in the generated completion
   */
  completion_tokens: number;
  /**
   * Number of tokens in the input
   */
  prompt_tokens: number;
  /**
   * Total number of tokens used (prompt + completion)
   */
  total_tokens: number;
};

/**
 * Request to send a message to an NPC
 */
export type NpcChatCompletionRequest = {
  /**
   * Optional contextual information about the current state of your game world. This helps the NPC provide more relevant and immersive responses.
   * Include details like location, weather, time of day, nearby objects or characters, player inventory, quest status, or any other relevant context.
   * The more specific and detailed this information, the better the NPC can tailor its response to the situation.
   *
   */
  game_state_info?: string | null;
  /**
   * The message content from the player to the NPC. This can be dialogue, questions, commands, or any other form of communication.
   * The NPC will respond based on its personality, the message content, and any provided game state context.
   *
   */
  sender_message: string;
  /**
   * The name or identifier of the player sending the message. The NPC will use this to personalize responses and maintain conversational context.
   * Can be a character name, username, or any identifier that makes sense in your game context.
   *
   */
  sender_name: string;
  /**
   * Specifies how text-to-speech audio should be handled for the NPC's response.
   * - `"server"`: Audio is generated on our servers and returned as base64-encoded data
   * - `null`: No audio generation - text response only
   *
   */
  tts?: NpcTTS | null;
};

/**
 * Response from an NPC containing text message, optional audio, and/or function calls.
 * This is the format of responses streamed through the `/npcs/responses` endpoint.
 *
 */
export type NpcApiChatResponse = {
  /**
   * Optional audio data for the NPC's response. Present only if TTS was requested in the original message.
   * Contains base64-encoded audio data ready for playback.
   *
   */
  audio?: null | SingleTextToSpeechData;
  /**
   * Optional array of function calls that the NPC wants to execute. These represent actions the NPC is taking in your game world.
   * Your game should process these function calls and apply their effects. Functions can modify game state, trigger events, or perform other actions.
   *
   */
  command?: Array<FunctionCall> | null;
  /**
   * Optional error information when the NPC cannot process a request due to system issues.
   * When present, indicates that the NPC encountered an error and cannot provide a normal response.
   *
   */
  error?: null | NpcApiError;
  /**
   * The text response from the NPC. This is the conversational content that should be displayed to the player.
   * May be empty if the NPC is only executing functions without providing a text response, or if an error occurred.
   *
   */
  message: string;
  /**
   * The unique identifier of the NPC that generated this response. Use this to route the response to the correct character in your game.
   * This matches the UUID returned when the NPC was spawned.
   *
   */
  npc_id: string;
};

/**
 * Error information for NPC API responses when system errors occur.
 * Provides structured error details to help developers handle different error conditions.
 *
 */
export type NpcApiError = {
  /**
   * Machine-readable error code indicating the type of error that occurred.
   * - `insufficient_credits`: User has run out of AI power/credits and needs to top up their account
   * - `service_unavailable`: The AI service is temporarily unavailable
   * - `rate_limited`: Too many requests have been made in a short time period
   * - `internal_error`: An unexpected system error occurred
   *
   */
  error_code:
    | 'insufficient_credits'
    | 'service_unavailable'
    | 'rate_limited'
    | 'internal_error';
  /**
   * Human-readable error message providing details about the error.
   * This message can be displayed to users to explain what went wrong and how to resolve it.
   *
   */
  error_message: string;
  /**
   * Optional number of seconds to wait before retrying the request.
   * Present for rate_limited and service_unavailable errors.
   *
   */
  retry_after?: number | null;
};

/**
 * Machine-readable error code indicating the type of error that occurred.
 * - `insufficient_credits`: User has run out of AI power/credits and needs to top up their account
 * - `service_unavailable`: The AI service is temporarily unavailable
 * - `rate_limited`: Too many requests have been made in a short time period
 * - `internal_error`: An unexpected system error occurred
 *
 */
export type error_code =
  | 'insufficient_credits'
  | 'service_unavailable'
  | 'rate_limited'
  | 'internal_error';

/**
 * Response containing the complete conversation history for an NPC.
 * Includes all messages exchanged between players and the NPC in chronological order.
 *
 */
export type NpcHistoryResponse = {
  /**
   * The unique identifier of the NPC whose history is being returned.
   * This matches the UUID returned when the NPC was spawned.
   *
   */
  npc_id: string;
  /**
   * Array of conversation messages in chronological order.
   * Contains all user and assistant messages that form the NPC's conversation context.
   *
   */
  history: Array<Message>;
};

export type NpcFunction = Function & unknown;

/**
 * Single Text to Speech Data
 */
export type SingleTextToSpeechData = {
  /**
   * Base64 encoded audio data
   */
  data: string;
};

/**
 * Text-to-speech configuration for an NPC. This defines how the NPC's responses should be converted to audio.
 * All fields from TTSSpeakRequest except 'text' are supported, allowing full control over voice characteristics.
 *
 */
export type NpcTTSConfig = {
  /**
   * Voice ids to use for this NPC. If not provided, the default voice for the language and gender will be used.
   * If providing more than one voice, the voices will be mixed together.
   *
   */
  voice_ids?: Array<string>;
  /**
   * Speed of the speech for this NPC
   */
  speed: number;
  /**
   * The audio format for this NPC's responses
   */
  audio_format: 'mp3' | 'opus' | 'flac' | 'wav' | 'pcm';
  /**
   * The gender of the default voice to use if no voice_ids are provided
   */
  voice_gender?: SpeechGender;
  /**
   * The language of the default voice to use if no voice_ids are provided
   */
  voice_language?:
    | 'en_US'
    | 'en_GB'
    | 'ja_JP'
    | 'zh_CN'
    | 'es_ES'
    | 'fr_FR'
    | 'hi_IN'
    | 'it_IT'
    | 'pt_BR';
};

export type SpawnNPC = {
  /**
   * A detailed description of your NPC's personality, background, and traits. This shapes how the AI will behave and respond to players.
   * Think of this as the character's "bio" - include their motivations, quirks, speaking style, and any unique characteristics.
   *
   */
  character_description: string;
  /**
   * An optional array of custom functions/commands that your NPC can execute. These allow the NPC to interact with your game world beyond just conversation.
   * Each function should have a clear purpose and well-defined parameters. The NPC will intelligently decide when to call these functions based on the conversation context.
   *
   */
  commands?: Array<NpcFunction> | null;
  /**
   * Controls whether game state information is preserved in the NPC's conversation history.
   * - `true` (default): Game state context is remembered across conversations for continuity
   * - `false`: Each conversation starts fresh without previous game state context
   * - `null`: Uses system default behavior
   *
   */
  keep_game_state?: boolean | null;
  /**
   * The complete, formal name of your character. This is used for identification and can be referenced in conversations.
   * Use a name that fits your game's setting and the character's background.
   *
   */
  name: string;
  /**
   * A shorter version of the character's name, typically used in UI elements like chat bubbles or character lists.
   * This should be easy to read and recognize at a glance.
   *
   */
  short_name: string;
  /**
   * Core instructions that define how the AI should behave as this character. This is the most important field for shaping your NPC's personality and behavior.
   * Include guidelines for tone, knowledge areas, goals, and any specific rules the character should follow.
   *
   */
  system_prompt: string;
  /**
   * Text-to-speech configuration for this NPC. Defines voice characteristics, speed, and audio format for when players request audio responses.
   * Use the [/tts/voices](#tag/Text-To-Speech/operation/tts_voices) endpoint to get available voice options and their IDs.
   *
   */
  tts: NpcTTSConfig;
  /**
   * **Backward compatibility field for player2 app.**
   * Voice ID to use for this NPC. If both `voice_id` and `tts.voice_id` are provided, `tts.voice_id` takes precedence.
   * If `tts.voice_id` is empty, this field will be used instead.
   *
   */
  voice_id?: string;
};

/**
 * Specifies how text-to-speech audio should be generated and delivered for NPC responses.
 * Choose the option that best fits your application's architecture and bandwidth requirements.
 *
 */
export type NpcTTS = 'server';

/**
 * WebSocket message envelope for STT events
 */
export type STTEnvelope = {
  /**
   * Event type
   */
  type:
    | 'session'
    | 'open'
    | 'message'
    | 'speech_started'
    | 'utterance_end'
    | 'error'
    | 'close';
  /**
   * Stream session identifier
   */
  stream_id: string;
  /**
   * Unix timestamp in milliseconds
   */
  timestamp: number;
  /**
   * Event-specific data
   */
  data:
    | STTSessionEvent
    | STTOpenEvent
    | STTMessageEvent
    | STTSpeechStartedEvent
    | STTUtteranceEndEvent
    | STTErrorEvent
    | STTCloseEvent;
};

/**
 * Event type
 */
export type type3 =
  | 'session'
  | 'open'
  | 'message'
  | 'speech_started'
  | 'utterance_end'
  | 'error'
  | 'close';

/**
 * Session establishment event
 */
export type STTSessionEvent = {
  /**
   * Unique session identifier for reconnection
   */
  stream_id: string;
};

/**
 * Transcriber connection opened event
 */
export type STTOpenEvent = {
  type?: string;
};

/**
 * Transcription result event (interim or final)
 */
export type STTMessageEvent = {
  channel?: STTChannel;
  channel_index?: Array<number>;
  duration?: number;
  /**
   * Whether this is the final transcription result
   */
  is_final?: boolean;
  from_finalize?: boolean;
  metadata?: STTMetadata;
  speech_final?: boolean;
  start?: number;
  type?: string;
};

/**
 * Transcription channel data
 */
export type STTChannel = {
  alternatives?: Array<STTAlternative>;
};

/**
 * Transcription alternative result
 */
export type STTAlternative = {
  /**
   * Confidence score (0.0 to 1.0)
   */
  confidence?: number;
  /**
   * Transcribed text
   */
  transcript?: string;
  words?: Array<STTWord>;
};

/**
 * Individual word with timing information
 */
export type STTWord = {
  /**
   * The transcribed word
   */
  word?: string;
  /**
   * Start time in seconds
   */
  start?: number;
  /**
   * End time in seconds
   */
  end?: number;
  /**
   * Confidence score for this word
   */
  confidence?: number;
  /**
   * Speaker identifier (when diarization is enabled)
   */
  speaker?: number;
};

/**
 * Transcription metadata
 */
export type STTMetadata = {
  request_id?: string;
  transaction_key?: string;
  sha256?: string;
  created?: string;
  duration?: number;
  channels?: number;
};

/**
 * Voice activity detection - speech started
 */
export type STTSpeechStartedEvent = {
  type?: string;
};

/**
 * End of utterance detected (silence after speech)
 */
export type STTUtteranceEndEvent = {
  type?: string;
};

/**
 * Error event from transcriber
 */
export type STTErrorEvent = {
  type?: string;
  /**
   * Specific error code
   */
  err_code:
    | 'CONNECTION_FAILED'
    | 'CONNECTION_TIMEOUT'
    | 'CONNECTION_LOST'
    | 'RECONNECT_FAILED'
    | 'AUTHENTICATION_FAILED'
    | 'INVALID_API_KEY'
    | 'UNAUTHORIZED'
    | 'INVALID_CONFIGURATION'
    | 'UNSUPPORTED_FORMAT'
    | 'INVALID_SAMPLE_RATE'
    | 'AUDIO_VALIDATION_ERROR'
    | 'BUFFER_OVERFLOW'
    | 'AUDIO_PROCESSING_ERROR'
    | 'RATE_LIMIT_EXCEEDED'
    | 'QUOTA_EXCEEDED'
    | 'SESSION_NOT_FOUND'
    | 'SESSION_EXPIRED'
    | 'SESSION_CLOSED'
    | 'INTERNAL_ERROR'
    | 'SERVICE_UNAVAILABLE'
    | 'DEEPGRAM_ERROR';
  /**
   * Human-readable error message
   */
  err_msg: string;
  /**
   * Detailed error description
   */
  description?: string;
  variant?: string;
};

/**
 * Specific error code
 */
export type err_code =
  | 'CONNECTION_FAILED'
  | 'CONNECTION_TIMEOUT'
  | 'CONNECTION_LOST'
  | 'RECONNECT_FAILED'
  | 'AUTHENTICATION_FAILED'
  | 'INVALID_API_KEY'
  | 'UNAUTHORIZED'
  | 'INVALID_CONFIGURATION'
  | 'UNSUPPORTED_FORMAT'
  | 'INVALID_SAMPLE_RATE'
  | 'AUDIO_VALIDATION_ERROR'
  | 'BUFFER_OVERFLOW'
  | 'AUDIO_PROCESSING_ERROR'
  | 'RATE_LIMIT_EXCEEDED'
  | 'QUOTA_EXCEEDED'
  | 'SESSION_NOT_FOUND'
  | 'SESSION_EXPIRED'
  | 'SESSION_CLOSED'
  | 'INTERNAL_ERROR'
  | 'SERVICE_UNAVAILABLE'
  | 'DEEPGRAM_ERROR';

/**
 * Connection closed event
 */
export type STTCloseEvent = {
  type?: string;
};

/**
 * Audio configuration for transcription
 */
export type AudioConfig = {
  /**
   * Audio encoding format
   */
  encoding?:
    | 'linear16'
    | 'flac'
    | 'mulaw'
    | 'alaw'
    | 'mp3'
    | 'mp4'
    | 'opus'
    | 'wav';
  /**
   * Audio sample rate in Hz (e.g., "44100", "48000")
   */
  sample_rate?: string;
  /**
   * BCP-47 language tag for transcription
   */
  language?:
    | 'en'
    | 'en-US'
    | 'en-AU'
    | 'en-GB'
    | 'en-NZ'
    | 'en-IN'
    | 'es'
    | 'es-419'
    | 'fr'
    | 'fr-CA'
    | 'de'
    | 'it'
    | 'pt'
    | 'pt-BR'
    | 'ru'
    | 'hi'
    | 'ja'
    | 'ko'
    | 'zh'
    | 'zh-CN'
    | 'zh-TW'
    | 'nl'
    | 'tr'
    | 'pl'
    | 'sv'
    | 'no'
    | 'da'
    | 'fi'
    | 'uk'
    | 'el'
    | 'cs';
};

/**
 * Audio encoding format
 */
export type encoding =
  | 'linear16'
  | 'flac'
  | 'mulaw'
  | 'alaw'
  | 'mp3'
  | 'mp4'
  | 'opus'
  | 'wav';

/**
 * BCP-47 language tag for transcription
 */
export type language =
  | 'en'
  | 'en-US'
  | 'en-AU'
  | 'en-GB'
  | 'en-NZ'
  | 'en-IN'
  | 'es'
  | 'es-419'
  | 'fr'
  | 'fr-CA'
  | 'de'
  | 'it'
  | 'pt'
  | 'pt-BR'
  | 'ru'
  | 'hi'
  | 'ja'
  | 'ko'
  | 'zh'
  | 'zh-CN'
  | 'zh-TW'
  | 'nl'
  | 'tr'
  | 'pl'
  | 'sv'
  | 'no'
  | 'da'
  | 'fi'
  | 'uk'
  | 'el'
  | 'cs';

/**
 * Audio transcription result
 */
export type AudioTranscription = {
  /**
   * The transcribed text from the audio
   */
  transcript: string;
  /**
   * Confidence score for the transcription (0.0 to 1.0)
   */
  confidence: number;
  /**
   * Individual words with timing information (optional)
   */
  words?: Array<STTWord>;
  /**
   * Duration of the audio in seconds
   */
  duration?: number;
};

export type ChatCompletionData = {
  requestBody: ChatCompletionRequest;
};

export type ChatCompletionResponse = ChatCompletionJSONResponse;

export type LoginDeviceNewData = {
  requestBody: LoginDeviceNewRequest;
};

export type LoginDeviceNewResponse2 = LoginDeviceNewResponse;

export type LoginDeviceTokenData = {
  requestBody: LoginDeviceTokenRequest;
};

export type LoginDeviceTokenResponse2 = LoginDeviceTokenResponse;

export type LoginAuthorizationCodeTokenData = {
  requestBody: LoginAuthorizationCodeTokenRequest;
};

export type LoginAuthorizationCodeTokenResponse2 =
  LoginAuthorizationCodeTokenResponse;

export type HealthResponse2 = HealthResponse;

export type TtsVoicesResponse = TTSVoicesResponse;

export type TtsSpeakData = {
  requestBody: TTSSpeakRequest;
};

export type TtsSpeakResponse = TTSSpeakResponse;

export type TtsStreamData = {
  /**
   * If true, forces the use of Kokoro instead of Resemble even for patrons
   */
  disableAdvanced?: boolean;
  requestBody: TTSStreamRequest;
};

export type TtsStreamResponse = Blob | File;

export type SttStreamData = {
  /**
   * Enable speaker diarization (identify different speakers)
   */
  diarize?: boolean;
  /**
   * Audio encoding format
   */
  encoding?:
    | 'linear16'
    | 'flac'
    | 'mulaw'
    | 'alaw'
    | 'mp3'
    | 'mp4'
    | 'opus'
    | 'wav';
  /**
   * Enable real-time interim transcription results
   */
  interimResults?: boolean;
  /**
   * BCP-47 language tag for transcription
   */
  language?:
    | 'en'
    | 'en-US'
    | 'en-AU'
    | 'en-GB'
    | 'en-NZ'
    | 'en-IN'
    | 'es'
    | 'es-419'
    | 'fr'
    | 'fr-CA'
    | 'de'
    | 'it'
    | 'pt'
    | 'pt-BR'
    | 'ru'
    | 'hi'
    | 'ja'
    | 'ko'
    | 'zh'
    | 'zh-CN'
    | 'zh-TW'
    | 'nl'
    | 'tr'
    | 'pl'
    | 'sv'
    | 'no'
    | 'da'
    | 'fi'
    | 'uk'
    | 'el'
    | 'cs';
  /**
   * Audio sample rate in Hz (e.g., "44100", "48000")
   */
  sampleRate: string;
  /**
   * Optional stream ID to reconnect to existing session
   */
  streamId?: string;
  /**
   * Milliseconds to wait before sending utterance end event (1000-5000ms)
   */
  utteranceEndMs?: string;
  /**
   * Enable voice activity detection events
   */
  vadEvents?: boolean;
};

export type SttAudioData = {
  /**
   * Audio encoding format
   */
  encoding?:
    | 'linear16'
    | 'flac'
    | 'mulaw'
    | 'alaw'
    | 'mp3'
    | 'mp4'
    | 'opus'
    | 'wav';
  /**
   * BCP-47 language tag for transcription
   */
  language?:
    | 'en'
    | 'en-US'
    | 'en-AU'
    | 'en-GB'
    | 'en-NZ'
    | 'en-IN'
    | 'es'
    | 'es-419'
    | 'fr'
    | 'fr-CA'
    | 'de'
    | 'it'
    | 'pt'
    | 'pt-BR'
    | 'ru'
    | 'hi'
    | 'ja'
    | 'ko'
    | 'zh'
    | 'zh-CN'
    | 'zh-TW'
    | 'nl'
    | 'tr'
    | 'pl'
    | 'sv'
    | 'no'
    | 'da'
    | 'fi'
    | 'uk'
    | 'el'
    | 'cs';
  requestBody: Blob | File;
  /**
   * Audio sample rate in Hz (e.g., "44100", "48000")
   */
  sampleRate?: string;
};

export type SttAudioResponse = AudioTranscription;

export type SelectedCharactersResponse2 = SelectedCharactersResponse;

export type GetJoulesResponse = JoulesResponse;

export type NpcChatStreamData = {
  /**
   * Content type for the response stream:
   * - `application/json`: Newline-delimited JSON streaming
   * - `text/event-stream`: Server-Sent Events following EventSource specification
   *
   */
  accept?: 'application/json' | 'text/event-stream';
  /**
   * Optional bearer token for clients (like EventSource) that cannot set the Authorization header.
   * When provided, it should contain the same value you'd otherwise pass as a Bearer token.
   *
   */
  token?: string;
  /**
   * If true, TTS audio is streamed as base64 PCM16 chunks and the text is sent immediately.
   * If false (default), TTS is generated synchronously and the text is not sent early.
   *
   */
  ttsStreaming?: boolean;
};

export type NpcChatStreamResponse = NpcApiChatResponse;

export type CreateAiNpcData = {
  requestBody: SpawnNPC;
};

export type CreateAiNpcResponse = string;

export type NpcChatData = {
  /**
   * UUID of the NPC to send the message to (returned from /npcs/spawn)
   */
  npcId: string;
  requestBody: NpcChatCompletionRequest;
};

export type NpcChatResponse = unknown;

export type KillNpcData = {
  /**
   * UUID of the NPC to remove (returned from /npcs/spawn)
   */
  npcId: string;
};

export type KillNpcResponse = unknown;

export type GetNpcHistoryData = {
  /**
   * UUID of the NPC to get conversation history for (returned from /npcs/spawn)
   */
  npcId: string;
};

export type GetNpcHistoryResponse = NpcHistoryResponse;

export type $OpenApiTs = {
  '/chat/completions': {
    post: {
      req: ChatCompletionData;
      res: {
        200: ChatCompletionJSONResponse;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Insufficient credits to complete the request.
         */
        402: string;
        /**
         * Too many requests have been made to the server.
         */
        429: string;
        /**
         * Internal server error
         */
        500: unknown;
        /**
         * Error response
         */
        default: RequestError;
      };
    };
  };
  '/login/device/new': {
    post: {
      req: LoginDeviceNewData;
      res: {
        200: LoginDeviceNewResponse;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/login/device/token': {
    post: {
      req: LoginDeviceTokenData;
      res: {
        200: LoginDeviceTokenResponse;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/login/authorization_code/token': {
    post: {
      req: LoginAuthorizationCodeTokenData;
      res: {
        200: LoginAuthorizationCodeTokenResponse;
        /**
         * Invalid request. Common errors:
         * - `invalid_request`: Missing or invalid required parameters
         * - `invalid_grant`: Invalid authorization code, expired, or PKCE validation failed
         * - `unsupported_grant_type`: Grant type is not `authorization_code`
         *
         */
        400: RequestError;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/health': {
    get: {
      res: {
        200: HealthResponse;
      };
    };
  };
  '/tts/voices': {
    get: {
      res: {
        200: TTSVoicesResponse;
      };
    };
  };
  '/tts/speak': {
    post: {
      req: TtsSpeakData;
      res: {
        200: TTSSpeakResponse;
        /**
         * Invalid request
         */
        400: unknown;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Insufficient credits to complete the request.
         */
        402: unknown;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/tts/stream': {
    post: {
      req: TtsStreamData;
      res: {
        /**
         * Streaming audio data
         */
        200: Blob | File;
        /**
         * Invalid request
         */
        400: unknown;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Insufficient credits to complete the request.
         */
        402: unknown;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/stt/stream': {
    get: {
      req: SttStreamData;
      res: {
        /**
         * WebSocket connection established. Messages follow STTEnvelope schema.
         */
        101: STTEnvelope;
        /**
         * Invalid request parameters
         */
        400: unknown;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/stt/audio': {
    post: {
      req: SttAudioData;
      res: {
        /**
         * Transcription successful
         */
        200: AudioTranscription;
        /**
         * Invalid request parameters or audio format
         */
        400: unknown;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Insufficient credits to complete the request.
         */
        402: unknown;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/selected_characters': {
    get: {
      res: {
        200: SelectedCharactersResponse;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/joules': {
    get: {
      res: {
        /**
         * Successfully retrieved joule information
         */
        200: JoulesResponse;
        /**
         * The user must be authenticated.
         */
        401: unknown;
        /**
         * Internal server error
         */
        500: unknown;
      };
    };
  };
  '/npcs/responses': {
    get: {
      req: NpcChatStreamData;
      res: {
        /**
         * Successful connection established. Response format depends on the Accept header:
         * - `application/json`: Newline-delimited JSON streaming with each line containing a complete NpcApiChatResponse object
         * - `text/event-stream`: Server-Sent Events following EventSource specification with JSON data in the data: field
         *
         */
        200: NpcApiChatResponse;
        /**
         * Authentication required - provide a valid Bearer token
         */
        401: unknown;
        /**
         * Rate limit exceeded - too many concurrent connections
         */
        429: unknown;
        /**
         * Internal server error - try reconnecting after a brief delay
         */
        500: unknown;
      };
    };
  };
  '/npcs/spawn': {
    post: {
      req: CreateAiNpcData;
      res: {
        /**
         * NPC successfully created. The response contains the unique identifier for your new NPC.
         * Use this UUID for sending messages, receiving responses, and eventually removing the NPC.
         *
         */
        200: string;
        /**
         * Invalid request - check your character configuration and function definitions
         */
        400: unknown;
        /**
         * Authentication required - provide a valid Bearer token
         */
        401: unknown;
        /**
         * Rate limit exceeded - too many NPCs created recently
         */
        429: unknown;
        /**
         * Internal server error - please try again
         */
        500: unknown;
      };
    };
  };
  '/npcs/{npc_id}/chat': {
    post: {
      req: NpcChatData;
      res: {
        /**
         * Message successfully received and queued for processing. The NPC will generate a response that will be streamed to the `/npcs/responses` endpoint.
         * Listen to that endpoint to receive the NPC's reply.
         *
         */
        200: unknown;
        /**
         * Authentication required - provide a valid Bearer token
         */
        401: unknown;
        /**
         * NPC not found - the specified npc_id does not exist or has been deleted
         */
        404: unknown;
        /**
         * Rate limit exceeded - too many messages sent recently
         */
        429: unknown;
        /**
         * Internal server error - please try again
         */
        500: unknown;
      };
    };
  };
  '/npcs/{npc_id}/kill': {
    post: {
      req: KillNpcData;
      res: {
        /**
         * NPC successfully removed. The NPC and all its associated data have been permanently deleted.
         * The npc_id is now invalid and cannot be used for further operations.
         *
         */
        200: unknown;
        /**
         * Authentication required - provide a valid Bearer token
         */
        401: unknown;
        /**
         * NPC not found - the specified npc_id does not exist or has already been deleted
         */
        404: unknown;
        /**
         * Internal server error - please try again
         */
        500: unknown;
      };
    };
  };
  '/npcs/{npc_id}/history': {
    get: {
      req: GetNpcHistoryData;
      res: {
        /**
         * Successfully retrieved NPC conversation history. Contains all messages in chronological order.
         *
         */
        200: NpcHistoryResponse;
        /**
         * Authentication required - provide a valid Bearer token
         */
        401: unknown;
        /**
         * NPC not found - the specified npc_id does not exist or has been deleted
         */
        404: unknown;
        /**
         * Internal server error - please try again
         */
        500: unknown;
      };
    };
  };
};
