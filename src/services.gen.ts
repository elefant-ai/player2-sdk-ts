// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type {
  ChatCompletionData,
  ChatCompletionResponse,
  LoginDeviceNewData,
  LoginDeviceNewResponse2,
  LoginDeviceTokenData,
  LoginDeviceTokenResponse2,
  LoginAuthorizationCodeTokenData,
  LoginAuthorizationCodeTokenResponse2,
  HealthResponse2,
  TtsVoicesResponse,
  TtsSpeakData,
  TtsSpeakResponse,
  TtsStreamData,
  TtsStreamResponse,
  SttStreamData,
  SttAudioData,
  SttAudioResponse,
  SelectedCharactersResponse2,
  GetJoulesResponse,
  NpcChatStreamData,
  NpcChatStreamResponse,
  CreateAiNpcData,
  CreateAiNpcResponse,
  NpcChatData,
  NpcChatResponse,
  KillNpcData,
  KillNpcResponse,
  GetNpcHistoryData,
  GetNpcHistoryResponse,
} from './types.gen';

/**
 * Create chat completion
 * Creates a chat response for the provided messages. This endpoint supports both
 * streaming and non-streaming responses based on the `stream` parameter in the request.
 *
 * - If `stream` is `false` or not provided, returns a standard JSON response.
 * - If `stream` is `true`, returns a Server-Sent Events (SSE) stream.
 *
 * This is intended to follow the [OpenAI API](https://platform.openai.com/docs/api-reference/chat).
 * @param data The data for the request.
 * @param data.requestBody
 * @returns ChatCompletionJSONResponse
 * @throws ApiError
 */
export const chatCompletion = (
  data: ChatCompletionData,
): CancelablePromise<ChatCompletionResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/chat/completions',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      401: 'The user must be authenticated.',
      402: 'Insufficient credits to complete the request.',
      429: 'Too many requests have been made to the server.',
      500: 'Internal server error',
      default: 'Error response',
    },
  });
};

/**
 * Start the flow
 * Starts a new device login for the user.
 * When you receive the `verificationUri` and `userCode` (or `verificationUriComplete`)
 * field you should redirect the user to the url to approve access. The user may need to type
 * in the `userCode` to approve access.
 * The user must approve within `expiresIn` seconds or the flow will fail.
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns LoginDeviceNewResponse
 * @throws ApiError
 */
export const loginDeviceNew = (
  data: LoginDeviceNewData,
): CancelablePromise<LoginDeviceNewResponse2> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/login/device/new',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      500: 'Internal server error',
    },
  });
};

/**
 * Poll for the api key
 * Poll for the new api key after starting the flow. The user must approve access via the Player2 website at the url
 * provided in the `verification_uri` (or `verification_uri_complete`) field of the response to `/login/device/new`.
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns LoginDeviceTokenResponse
 * @throws ApiError
 */
export const loginDeviceToken = (
  data: LoginDeviceTokenData,
): CancelablePromise<LoginDeviceTokenResponse2> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/login/device/token',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      500: 'Internal server error',
    },
  });
};

/**
 * Exchange authorization code for API key
 * Exchange an authorization code for a P2 API key using OAuth2 Authorization Code flow with PKCE.
 * This endpoint should be called after obtaining an authorization code from the authorization server.
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns LoginAuthorizationCodeTokenResponse
 * @throws ApiError
 */
export const loginAuthorizationCodeToken = (
  data: LoginAuthorizationCodeTokenData,
): CancelablePromise<LoginAuthorizationCodeTokenResponse2> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/login/authorization_code/token',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: `Invalid request. Common errors:
- \`invalid_request\`: Missing or invalid required parameters
- \`invalid_grant\`: Invalid authorization code, expired, or PKCE validation failed
- \`unsupported_grant_type\`: Grant type is not \`authorization_code\`
`,
      500: 'Internal server error',
    },
  });
};

/**
 * Check the health of the API
 * @returns HealthResponse
 * @throws ApiError
 */
export const health = (): CancelablePromise<HealthResponse2> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/health',
  });
};

/**
 * Get available voices
 * This endpoint returns a list of available voices that can be used with the `/tts/speak` endpoint. You can even mix and match voices
 * together by providing multiple ids.
 *
 * @returns TTSVoicesResponse
 * @throws ApiError
 */
export const ttsVoices = (): CancelablePromise<TtsVoicesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/tts/voices',
  });
};

/**
 * Speak text
 * This endpoint returns the full audio file for the text and voice provided.
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns TTSSpeakResponse
 * @throws ApiError
 */
export const ttsSpeak = (
  data: TtsSpeakData,
): CancelablePromise<TtsSpeakResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/tts/speak',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Invalid request',
      401: 'The user must be authenticated.',
      402: 'Insufficient credits to complete the request.',
      500: 'Internal server error',
    },
  });
};

/**
 * Stream text-to-speech audio
 * This endpoint returns streaming audio data for the text and voice provided,
 * allowing for real-time audio playback as the audio is being synthesized.
 * Streaming only supports WAV and MP3 audio formats.
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @param data.disableAdvanced If true, forces the use of Kokoro instead of Resemble even for patrons
 * @returns binary Streaming audio data
 * @throws ApiError
 */
export const ttsStream = (
  data: TtsStreamData,
): CancelablePromise<TtsStreamResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/tts/stream',
    query: {
      'disable-advanced': data.disableAdvanced,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Invalid request',
      401: 'The user must be authenticated.',
      402: 'Insufficient credits to complete the request.',
      500: 'Internal server error',
    },
  });
};

/**
 * Real-time speech to text WebSocket stream
 * Establishes a WebSocket connection for real-time speech-to-text transcription.
 *
 * **WebSocket Protocol:**
 * - Upgrade to WebSocket using standard WebSocket handshake
 * - Send binary audio data (PCM/linear16 format by default)
 * - Receive JSON messages wrapped in STTEnvelope format
 *
 * **Message Format:**
 * All WebSocket messages follow the `STTEnvelope` schema with event-specific data.
 *
 * **Event Types:**
 * - `session`: Connection established with stream_id (`STTSessionEvent`)
 * - `open`: Transcriber connection opened (`STTOpenEvent`)
 * - `message`: Transcription result - interim or final (`STTMessageEvent`)
 * - `speech_started`: Voice activity detected (`STTSpeechStartedEvent`) - if vad_events=true
 * - `utterance_end`: End of speech detected (`STTUtteranceEndEvent`) - if utterance_end_ms is set
 * - `error`: Error occurred (`STTErrorEvent`)
 * - `close`: Connection closed (`STTCloseEvent`)
 *
 * **Audio Requirements:**
 * - Format: PCM/linear16 (16-bit signed integers)
 * - Sample Rate: As specified in sample_rate parameter (typically 44100 or 48000)
 * - Channels: Mono (1 channel)
 * - Send audio in ~50ms chunks for best results
 *
 * See the `STTEnvelope` and related schemas by expanding data field of 101 response:
 *
 * @param data The data for the request.
 * @param data.sampleRate Audio sample rate in Hz (e.g., "44100", "48000")
 * @param data.language BCP-47 language tag for transcription
 * @param data.encoding Audio encoding format
 * @param data.interimResults Enable real-time interim transcription results
 * @param data.utteranceEndMs Milliseconds to wait before sending utterance end event (1000-5000ms)
 * @param data.diarize Enable speaker diarization (identify different speakers)
 * @param data.vadEvents Enable voice activity detection events
 * @param data.streamId Optional stream ID to reconnect to existing session
 * @throws ApiError
 */
export const sttStream = (data: SttStreamData): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/stt/stream',
    query: {
      language: data.language,
      encoding: data.encoding,
      sample_rate: data.sampleRate,
      interim_results: data.interimResults,
      utterance_end_ms: data.utteranceEndMs,
      diarize: data.diarize,
      vad_events: data.vadEvents,
      stream_id: data.streamId,
    },
    errors: {
      400: 'Invalid request parameters',
      401: 'The user must be authenticated.',
      500: 'Internal server error',
    },
  });
};

/**
 * Transcribe audio file
 * Transcribes an audio file to text using speech-to-text technology.
 *
 * **Audio Requirements:**
 * - Send the raw audio bytes in the request body as application/octet-stream
 * - Specify the audio format via the `encoding` query parameter (linear16, flac, mulaw, alaw, mp3, mp4, opus, wav)
 * - Specify the sample rate via the `sample_rate` query parameter (e.g., "44100", "48000")
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @param data.encoding Audio encoding format
 * @param data.sampleRate Audio sample rate in Hz (e.g., "44100", "48000")
 * @param data.language BCP-47 language tag for transcription
 * @returns AudioTranscription Transcription successful
 * @throws ApiError
 */
export const sttAudio = (
  data: SttAudioData,
): CancelablePromise<SttAudioResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/stt/audio',
    query: {
      encoding: data.encoding,
      sample_rate: data.sampleRate,
      language: data.language,
    },
    body: data.requestBody,
    mediaType: 'application/octet-stream',
    errors: {
      400: 'Invalid request parameters or audio format',
      401: 'The user must be authenticated.',
      402: 'Insufficient credits to complete the request.',
      500: 'Internal server error',
    },
  });
};

/**
 * Get User "My AI Friends" characters
 * This endpoint returns a list of characters that the user has selected as "My AI Friends" characters.
 *
 * @returns SelectedCharactersResponse
 * @throws ApiError
 */
export const selectedCharacters =
  (): CancelablePromise<SelectedCharactersResponse2> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/selected_characters',
      errors: {
        401: 'The user must be authenticated.',
        500: 'Internal server error',
      },
    });
  };

/**
 * Get user joule balance and patron tier
 * Returns the user's current joule balance and their patron tier.
 * If the user is not a patron, patron_tier will be an empty string.
 *
 * @returns JoulesResponse Successfully retrieved joule information
 * @throws ApiError
 */
export const getJoules = (): CancelablePromise<GetJoulesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/joules',
    errors: {
      401: 'The user must be authenticated.',
      500: 'Internal server error',
    },
  });
};

/**
 * Get real-time NPC chat responses
 * Establishes a persistent connection to receive real-time responses from all your NPCs. This endpoint supports both Server-Sent Events (SSE) and newline-delimited JSON streaming based on the `Accept` header.
 *
 * ## Content Types
 *
 * - **`application/json`**: Returns newline-delimited JSON responses
 * - **`text/event-stream`**: Returns Server-Sent Events following the EventSource specification
 *
 * ## How It Works
 *
 * - **Keep the connection open**: This endpoint is designed for long-lived connections during active gameplay
 * - **Automatic routing**: Each response includes an `npc_id` so you can route replies to the correct NPC
 * - **Multiple response types**: Responses can contain text messages, function calls, and/or audio data
 * - **Automatic play tracking**: While connected, your play time is automatically tracked (no need to ping `/health`)
 *
 * ## Response Formats
 *
 * ### JSON Format (application/json)
 * Each line in the stream contains a complete JSON object:
 * ```json
 * {"npc_id": "123e4567-e89b-12d3-a456-426614174000", "message": "Ahoy there, matey!", "audio": {...}, "command": null, "error": null}
 * {"npc_id": "123e4567-e89b-12d3-a456-426614174000", "message": "", "audio": null, "command": [{"name": "set_weather", "arguments": {"condition": "stormy"}}], "error": null}
 * ```
 *
 * ### EventSource Format (text/event-stream)
 * Follows the EventSource specification with `id:`, `event:`, and `data:` fields:
 * ```
 * id: 1
 * event: npc_response
 * data: {"npc_id": "123e4567-e89b-12d3-a456-426614174000", "message": "Ahoy there, matey!", "audio": {...}, "command": null, "error": null}
 *
 * id: 2
 * event: npc_response
 * data: {"npc_id": "123e4567-e89b-12d3-a456-426614174000", "message": "", "audio": null, "command": [{"name": "set_weather", "arguments": {"condition": "stormy"}}], "error": null}
 *
 * event: ping
 * data: {"type": "ping"}
 * ```
 *
 * **Note**: Ping events are sent every 15 seconds to keep connections alive. They have no `id` field and are automatically filtered out for `application/json` clients.
 *
 * ## Integration Tips
 *
 * - **JSON Format**: Parse each line as separate JSON (newline-delimited JSON format)
 * - **EventSource Format**: Use the browser's EventSource API or equivalent SSE client
 * - Handle connection drops gracefully and reconnect as needed
 * - Buffer responses if your game loop can't process them immediately
 * - Use the `npc_id` to update the correct character's dialogue in your UI
 * - **Error Handling**: Check the `error` field in each response. When present, display the error message to users and handle accordingly:
 * - `insufficient_credits`: Show users they need to top up their AI power in the Player2 app
 * - `service_unavailable`: Inform users the service is temporarily down and to try again later
 * - `rate_limited`: Implement backoff and retry logic based on `retry_after` value
 *
 * ## Examples
 *
 * ### JSON Streaming
 * ```bash
 * curl -X GET "https://api.player2.game/v1/npcs/responses" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Accept: application/json" \
 * -N --http2
 * ```
 *
 * ### EventSource/SSE
 * ```bash
 * curl -X GET "https://api.player2.game/v1/npcs/responses" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Accept: text/event-stream" \
 * -N --http2
 * ```
 *
 * ```javascript
 * // Browser EventSource example
 * const eventSource = new EventSource('/npcs/responses', {
 * headers: { 'Authorization': 'Bearer YOUR_TOKEN' }
 * });
 * eventSource.addEventListener('npc_response', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('NPC Response:', data);
 * });
 * ```
 *
 * @param data The data for the request.
 * @param data.accept Content type for the response stream:
 * - `application/json`: Newline-delimited JSON streaming
 * - `text/event-stream`: Server-Sent Events following EventSource specification
 *
 * @param data.token Optional bearer token for clients (like EventSource) that cannot set the Authorization header.
 * When provided, it should contain the same value you'd otherwise pass as a Bearer token.
 *
 * @param data.ttsStreaming If true, TTS audio is streamed as base64 PCM16 chunks and the text is sent immediately.
 * If false (default), TTS is generated synchronously and the text is not sent early.
 *
 * @returns NpcApiChatResponse Successful connection established. Response format depends on the Accept header:
 * - `application/json`: Newline-delimited JSON streaming with each line containing a complete NpcApiChatResponse object
 * - `text/event-stream`: Server-Sent Events following EventSource specification with JSON data in the data: field
 *
 * @throws ApiError
 */
export const npcChatStream = (
  data: NpcChatStreamData = {},
): CancelablePromise<NpcChatStreamResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/npcs/responses',
    headers: {
      Accept: data.accept,
    },
    query: {
      token: data.token,
      'tts-streaming': data.ttsStreaming,
    },
    errors: {
      401: 'Authentication required - provide a valid Bearer token',
      429: 'Rate limit exceeded - too many concurrent connections',
      500: 'Internal server error - try reconnecting after a brief delay',
    },
  });
};

/**
 * Spawn a new AI-powered NPC
 * Creates a new Non-Player Character with a unique personality, voice, and set of capabilities. The NPC will maintain its own conversation history and can respond to player messages, execute custom functions, and provide text-to-speech audio responses.
 *
 * ## What You Can Configure
 *
 * - **Personality & Behavior**: Define the character's description and system instructions
 * - **Voice**: Choose from available text-to-speech voices for audio responses
 * - **Custom Functions**: Give the NPC abilities to interact with your game world
 * - **Conversation Persistence**: Control whether game state is remembered between messages
 *
 * ## Function Capabilities
 *
 * NPCs can execute custom functions in your game, such as:
 * - Modifying game state (weather, time, inventory)
 * - Triggering events or cutscenes
 * - Providing game information (quests, locations, items)
 * - Controlling other game systems
 *
 * Each function can optionally prevent the NPC from sending a text response, useful for silent actions.
 *
 * ## Example Usage
 *
 * ```bash
 * curl -X POST "https://api.player2.game/v1/npcs/spawn" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Content-Type: application/json" \
 * -d '{
 * "name": "Merlin the Wise",
 * "short_name": "Merlin",
 * "character_description": "An ancient wizard with vast knowledge of magic and the realm",
 * "system_prompt": "You are Merlin, a wise and helpful wizard. Speak with wisdom and offer magical assistance to worthy adventurers. You can cast spells to help players.",
 * "tts": {
 * "voice_ids": ["21m00Tcm4TlvDq8ikWAM"],
 * "speed": 0.9,
 * "audio_format": "mp3",
 * "voice_gender": "male"
 * },
 * "keep_game_state": true,
 * "commands": [
 * {
 * "name": "cast_spell",
 * "description": "Cast a magical spell with various effects",
 * "parameters": {
 * "type": "object",
 * "properties": {
 * "spell_name": {
 * "type": "string",
 * "description": "Name of the spell to cast"
 * },
 * "target": {
 * "type": "string",
 * "description": "Target of the spell (player, enemy, environment)"
 * }
 * },
 * "required": ["spell_name"]
 * },
 * "never_respond_with_message": false
 * }
 * ]
 * }'
 * ```
 *
 * ## Response
 *
 * Returns a UUID that uniquely identifies your new NPC. Use this ID for all subsequent interactions.
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string NPC successfully created. The response contains the unique identifier for your new NPC.
 * Use this UUID for sending messages, receiving responses, and eventually removing the NPC.
 *
 * @throws ApiError
 */
export const createAiNpc = (
  data: CreateAiNpcData,
): CancelablePromise<CreateAiNpcResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/npcs/spawn',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Invalid request - check your character configuration and function definitions',
      401: 'Authentication required - provide a valid Bearer token',
      429: 'Rate limit exceeded - too many NPCs created recently',
      500: 'Internal server error - please try again',
    },
  });
};

/**
 * Send message to an NPC
 * Sends a player’s message to an NPC that you previously spawned with `/npcs/spawn`.
 *
 * - Provide the `npc_id` of the target NPC in the path.
 * - The request includes the player’s name, message, and optional game state info.
 * - You can also specify TTS options so responses come back with audio.
 *
 * @param data The data for the request.
 * @param data.npcId UUID of the NPC to send the message to (returned from /npcs/spawn)
 * @param data.requestBody
 * @returns unknown Message successfully received and queued for processing. The NPC will generate a response that will be streamed to the `/npcs/responses` endpoint.
 * Listen to that endpoint to receive the NPC's reply.
 *
 * @throws ApiError
 */
export const npcChat = (
  data: NpcChatData,
): CancelablePromise<NpcChatResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/npcs/{npc_id}/chat',
    path: {
      npc_id: data.npcId,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      401: 'Authentication required - provide a valid Bearer token',
      404: 'NPC not found - the specified npc_id does not exist or has been deleted',
      429: 'Rate limit exceeded - too many messages sent recently',
      500: 'Internal server error - please try again',
    },
  });
};

/**
 * Remove an NPC
 * Permanently removes an NPC from the system, including all its conversation history, personality state, and any associated data. This action cannot be undone.
 *
 * ## What Gets Deleted
 *
 * - **NPC identity and configuration**: Name, personality, voice settings, and functions
 * - **Conversation history**: All past messages and interactions with players
 * - **Internal state**: Any learned behaviors or temporary memory
 * - **Pending responses**: Any queued but undelivered messages from this NPC
 *
 * ## When to Use
 *
 * - **End of gameplay session**: Clean up NPCs when players disconnect or finish playing
 * - **Character lifecycle**: Remove NPCs that are no longer relevant to the story
 * - **Resource management**: Free up resources by removing unused NPCs
 * - **Privacy compliance**: Ensure player conversation data is deleted when requested
 *
 * ## Important Notes
 *
 * - This action is **irreversible** - you cannot recover the NPC or its data after deletion
 * - Any pending messages from this NPC will be discarded
 * - The `npc_id` becomes invalid and cannot be reused
 * - No further responses will be generated from this NPC
 *
 * ## Example Usage
 *
 * ```bash
 * curl -X POST "https://api.player2.game/v1/npcs/{npc_id}/kill" \
 * -H "Authorization: Bearer YOUR_TOKEN"
 * ```
 *
 * @param data The data for the request.
 * @param data.npcId UUID of the NPC to remove (returned from /npcs/spawn)
 * @returns unknown NPC successfully removed. The NPC and all its associated data have been permanently deleted.
 * The npc_id is now invalid and cannot be used for further operations.
 *
 * @throws ApiError
 */
export const killNpc = (
  data: KillNpcData,
): CancelablePromise<KillNpcResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/npcs/{npc_id}/kill',
    path: {
      npc_id: data.npcId,
    },
    errors: {
      401: 'Authentication required - provide a valid Bearer token',
      404: 'NPC not found - the specified npc_id does not exist or has already been deleted',
      500: 'Internal server error - please try again',
    },
  });
};

/**
 * Get NPC conversation history
 * Retrieves the complete conversation history for a specific NPC, including all messages exchanged between players and the NPC.
 *
 * ## What is Returned
 *
 * - **Full conversation history**: All user and assistant messages in chronological order
 * - **Message format**: Standard message objects with role, content, and optional metadata
 * - **Conversation context**: The complete context that the NPC uses to generate responses
 *
 * ## Use Cases
 *
 * - **Save/load game state**: Persist NPC conversation history across game sessions
 * - **Debug conversations**: Inspect the full conversation flow for troubleshooting
 * - **Analytics and insights**: Analyze player-NPC interaction patterns
 * - **Context sharing**: Share NPC conversation history between different parts of your game
 *
 * ## Example Usage
 *
 * ```bash
 * curl -X GET "https://api.player2.game/v1/npcs/{npc_id}/history" \
 * -H "Authorization: Bearer YOUR_TOKEN"
 * ```
 *
 * @param data The data for the request.
 * @param data.npcId UUID of the NPC to get conversation history for (returned from /npcs/spawn)
 * @returns NpcHistoryResponse Successfully retrieved NPC conversation history. Contains all messages in chronological order.
 *
 * @throws ApiError
 */
export const getNpcHistory = (
  data: GetNpcHistoryData,
): CancelablePromise<GetNpcHistoryResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/npcs/{npc_id}/history',
    path: {
      npc_id: data.npcId,
    },
    errors: {
      401: 'Authentication required - provide a valid Bearer token',
      404: 'NPC not found - the specified npc_id does not exist or has been deleted',
      500: 'Internal server error - please try again',
    },
  });
};
